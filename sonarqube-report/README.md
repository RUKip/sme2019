# Code analysis
## jedit 
#### Version 1.0 

**By: default**

*Date: 2020-01-13*

## Introduction
This document contains results of the code analysis of jedit



## Configuration

- Quality Profiles
    - Names: Sonar way [Java]; Sonar way [HTML]; Sonar way [XML]; 
    - Files: AW-PBFvdC6WUNCuIjV0t.json; AW-PBF2NC6WUNCuIjV7S.json; AW-PBF7bC6WUNCuIjV70.json; 
 - Quality Gate
    - Name: Sonar way
    - File: Sonar way.xml

## Synthesis
Quality Gate | Reliability | Security | Maintainability | Coverage | Duplications
:---:|:---:|:---:|:---:|:---:|:---:
ERROR | E | E | A | 0.0 % | 2.1 %

## Metrics

\ | Cyclomatic Complexity | Cognitive Complexity | Lines of code per file | Coverage | Comment density (%) | Duplication (%)
:---|:---:|:---:|:---:|:---:|:---:|:---:
Min | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0
Max | 22373.0 | 23616.0 | 115362.0 | 0.0 | 84.6 | 39.0

## Volume

Language|Number
---|---
Java|112890
HTML|107
XML|2365
Total|115362


## Issues count by severity and types

Type|Severity|Number
---|---|---
VULNERABILITY|BLOCKER|3
VULNERABILITY|CRITICAL|0
VULNERABILITY|MAJOR|0
VULNERABILITY|MINOR|255
VULNERABILITY|INFO|0
BUG|BLOCKER|14
BUG|CRITICAL|4
BUG|MAJOR|151
BUG|MINOR|48
BUG|INFO|0
CODE_SMELL|BLOCKER|26
CODE_SMELL|CRITICAL|810
CODE_SMELL|MAJOR|6082
CODE_SMELL|MINOR|2504
CODE_SMELL|INFO|68
SECURITY_HOTSPOT|BLOCKER|0
SECURITY_HOTSPOT|CRITICAL|0
SECURITY_HOTSPOT|MAJOR|0
SECURITY_HOTSPOT|MINOR|0
SECURITY_HOTSPOT|INFO|0


## Issues
Name|Description|Type|Severity|Number
---|---|---|---|---
Resources should be closed|Connections, streams, files, and other classes that implement the Closeable interface or its super-interface, <br /> AutoCloseable, needs to be closed after use. Further, that close call must be made in a finally block otherwise <br /> an exception could keep the call from being made. Preferably, when class implements AutoCloseable, resource should be created using <br /> "try-with-resources" pattern and will be closed automatically. <br /> Failure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box it's on to <br /> their knees. <br /> Noncompliant Code Example <br />  <br /> private void readTheFile() throws IOException { <br />   Path path = Paths.get(this.fileName); <br />   BufferedReader reader = Files.newBufferedReader(path, this.charset); <br />   // ... <br />   reader.close();  // Noncompliant <br />   // ... <br />   Files.lines("input.txt").forEach(System.out::println); // Noncompliant: The stream needs to be closed <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     for (String property : propertyList) { <br />       stream = new FileOutputStream("myfile.txt");  // Noncompliant <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close();  // Multiple streams were opened. Only the last is closed. <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> private void readTheFile(String fileName) throws IOException { <br />     Path path = Paths.get(fileName); <br />     try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { <br />       reader.readLine(); <br />       // ... <br />     } <br />     // .. <br />     try (Stream&lt;String&gt; input = Files.lines("input.txt"))  { <br />       input.forEach(System.out::println); <br />     } <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     stream = new FileOutputStream("myfile.txt"); <br />     for (String property : propertyList) { <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close(); <br />   } <br /> } <br />  <br /> Exceptions <br /> Instances of the following classes are ignored by this rule because close has no effect: <br />  <br />    java.io.ByteArrayOutputStream  <br />    java.io.ByteArrayInputStream  <br />    java.io.CharArrayReader  <br />    java.io.CharArrayWriter  <br />    java.io.StringReader  <br />    java.io.StringWriter  <br />  <br /> Java 7 introduced the try-with-resources statement, which implicitly closes Closeables. All resources opened in a try-with-resources <br /> statement are ignored by this rule.  <br />  <br /> try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { <br />   //... <br /> } <br /> catch ( ... ) { <br />   //... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-459 - Incomplete Cleanup  <br />    CERT, FIO04-J. - Release resources when they are no longer needed  <br />    CERT, FIO42-C. - Close files when they are no longer needed  <br />    Try With Resources  <br /> |BUG|BLOCKER|13
Loops should not be infinite|An infinite loop is one that will never end while the program is running, i.e., you have to kill the program to get out of the loop. Whether it is <br /> by meeting the loop's end condition or via a break, every loop should have an end condition. <br /> Noncompliant Code Example <br />  <br /> for (;;) {  // Noncompliant; end condition omitted <br />   // ... <br /> } <br />  <br /> int j; <br /> while (true) { // Noncompliant; end condition omitted <br />   j++; <br /> } <br />  <br /> int k; <br /> boolean b = true; <br /> while (b) { // Noncompliant; b never written to in loop <br />   k++; <br /> } <br />  <br /> Compliant Solution <br />  <br /> int j; <br /> while (true) { // reachable end condition added <br />   j++; <br />   if (j  == Integer.MIN_VALUE) {  // true at Integer.MAX_VALUE +1 <br />     break; <br />   } <br /> } <br />  <br /> int k; <br /> boolean b = true; <br /> while (b) { <br />   k++; <br />   b = k &lt; Integer.MAX_VALUE; <br /> } <br />  <br /> See <br />  <br />    CERT, MSC01-J. - Do not use an empty infinite loop  <br /> |BUG|BLOCKER|1
Jump statements should not occur in "finally" blocks|Using return, break, throw, and so on from a finally block suppresses the propagation of any <br /> unhandled Throwable which was thrown in the try or catch block. <br /> This rule raises an issue when a jump statement (break, continue, return, throw, and <br /> goto) would force control flow to leave a finally block.  <br /> Noncompliant Code Example <br />  <br /> public static void main(String[] args) { <br />   try { <br />     doSomethingWhichThrowsException(); <br />     System.out.println("OK");   // incorrect "OK" message is printed <br />   } catch (RuntimeException e) { <br />     System.out.println("ERROR");  // this message is not shown <br />   } <br /> } <br />  <br /> public static void doSomethingWhichThrowsException() { <br />   try { <br />     throw new RuntimeException(); <br />   } finally { <br />     for (int i = 0; i &lt; 10; i ++) { <br />       //... <br />       if (q == i) { <br />         break; // ignored <br />       } <br />     } <br />  <br />     /* ... */ <br />     return;      // Noncompliant - prevents the RuntimeException from being propagated <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public static void main(String[] args) { <br />   try { <br />     doSomethingWhichThrowsException(); <br />     System.out.println("OK"); <br />   } catch (RuntimeException e) { <br />     System.out.println("ERROR");  // "ERROR" is printed as expected <br />   } <br /> } <br />  <br /> public static void doSomethingWhichThrowsException() { <br />   try { <br />     throw new RuntimeException(); <br />   } finally { <br />     for (int i = 0; i &lt; 10; i ++) { <br />       //... <br />       if (q == i) { <br />         break; // ignored <br />       } <br />     } <br />  <br />     /* ... */ <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-584 - Return Inside Finally Block  <br />    CERT, ERR04-J. - Do not complete abruptly from a finally block  <br /> |BUG|CRITICAL|3
Getters and setters should access the expected fields|Getters and setters provide a way to enforce encapsulation by providing public methods that give controlled access to <br /> private fields. However in classes with multiple fields it is not unusual that cut and paste is used to quickly create the needed getters <br /> and setters, which can result in the wrong field being accessed by a getter or setter. <br /> This rule raises an issue in any of these cases: <br />  <br />    A setter does not update the field with the corresponding name.  <br />    A getter does not access the field with the corresponding name.  <br />  <br /> Noncompliant Code Example <br />  <br /> class A { <br />   private int x; <br />   private int y; <br />  <br />   public void setX(int val) { // Noncompliant: field 'x' is not updated <br />     this.y = val; <br />   } <br />  <br />   public int getY() { // Noncompliant: field 'y' is not used in the return value <br />     return this.x; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class A { <br />   private int x; <br />   private int y; <br />  <br />   public void setX(int val) { <br />     this.x = val; <br />   } <br />  <br />   public int getY() { <br />     return this.y; <br />   } <br /> } <br /> |BUG|CRITICAL|1
"<!DOCTYPE>" declarations should appear before "<html>" tags|The &lt;!DOCTYPE&gt; declaration tells the web browser which (X)HTML version is being used on the page, and therefore how to interpret <br /> the various elements. <br /> Validators also rely on it to know which rules to enforce. <br /> It should always preceed the &lt;html&gt; tag. <br /> Noncompliant Code Example <br />  <br /> &lt;html&gt;  &lt;!-- Noncompliant --&gt; <br /> ... <br /> &lt;/html&gt; <br />  <br /> Compliant Solution <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html&gt;  &lt;!-- Compliant --&gt; <br /> ... <br /> &lt;/html&gt; <br /> |BUG|MAJOR|21
"<title>" should be present in all pages|Titles are important because they are displayed in search engine results as well as the browser's toolbar. <br /> This rule verifies that the &lt;head&gt; tag contains a &lt;title&gt; one, and the &lt;html&gt; tag a <br /> &lt;head&gt; one. <br /> Noncompliant Code Example <br />  <br /> &lt;html&gt;         &lt;!-- Non-Compliant --&gt; <br />  <br /> &lt;body&gt; <br /> ... <br /> &lt;/body&gt; <br />  <br /> &lt;/html&gt; <br />  <br /> Compliant Solution <br />  <br /> &lt;html&gt;         &lt;!-- Compliant --&gt; <br />  <br /> &lt;head&gt; <br />   &lt;title&gt;Some relevant title&lt;/title&gt; <br /> &lt;/head&gt; <br />  <br /> &lt;body&gt; <br /> ... <br /> &lt;/body&gt; <br />  <br /> &lt;/html&gt; <br /> |BUG|MAJOR|20
"<html>" element should have a language attribute|The &lt;html&gt;&nbsp;element should provide the lang and/or xml:lang attribute in order to identify the <br /> default language of a document. <br /> It enables assistive technologies, such as screen readers,&nbsp;to provide a comfortable reading experience by adapting the pronunciation and <br /> accent to the language. It also helps braille translation software, telling it to switch the control codes for accented characters for instance. <br /> Other benefits of marking the language include: <br />  <br />    assisting user agents in providing dictionary definitions or helping users benefit from translation tools.  <br />    improving search engine ranking. <br />    <br />  <br /> Both the lang and the xml:lang attributes can take only one value. <br /> &nbsp; <br /> Noncompliant Code Example <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html&gt; &lt;!-- Noncompliant --&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;head&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;title&gt;A page written in english&lt;/title&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;meta content="text/html; charset=utf-8" /&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;/head&gt; &nbsp; <br />  <br />  <br /> &nbsp;&nbsp;&nbsp; &lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; &lt;/body&gt; <br /> &lt;/html&gt; <br />  <br /> Compliant Solution <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html lang="en"&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;head&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;title&gt;A page written in english&lt;/title&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;meta content="text/html; charset=utf-8" /&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;/head&gt; &nbsp; <br />  <br />  <br /> &nbsp;&nbsp;&nbsp; &lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; &lt;/body&gt; <br /> &lt;/html&gt; <br />  <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html lang="en" xml:lang="en"&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;head&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;title&gt;A page written in english&lt;/title&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;meta content="text/html; charset=utf-8" /&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;/head&gt; &nbsp; <br />  <br />  <br /> &nbsp;&nbsp;&nbsp; &lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; &lt;/body&gt; <br /> &lt;/html&gt; <br />  <br /> See <br />  <br />    WCAG2, H57 - Using language attributes on the html element  <br />    WCAG2, 3.1.1 - Language of Page  <br /> |BUG|MAJOR|21
Elements deprecated in HTML5 should not be used|With the advent of HTML5, many old elements were deprecated. To ensure the best user experience, deprecated elements should not be used. This rule <br /> checks for the following deprecated elements: <br />  <br />    <br />      <br />       Element <br />       Remediation Action <br />      <br />      <br />       basefont, big, blink, center, font, marquee, <br />       multicol, nobr, spacer, tt <br />       use CSS <br />      <br />      <br />       acronym <br />       use abbr <br />      <br />      <br />       applet <br />       use embed or object <br />      <br />      <br />       bgsound <br />       use audio <br />      <br />      <br />       frame, frameset, noframes <br />       restructure the page to remove frames <br />      <br />      <br />       isindex <br />       use form controls <br />      <br />      <br />       dir <br />       use ul <br />      <br />      <br />       hgroup <br />       use header or div <br />      <br />      <br />       listing <br />       use pre and code <br />      <br />      <br />       nextid <br />       use GUIDS <br />      <br />      <br />       noembed <br />       use object instead of embed when fallback is necessary <br />      <br />      <br />       plaintext <br />       use the "text/plain" MIME type <br />      <br />      <br />       strike <br />       use del or s <br />      <br />      <br />       xmp <br />       use pre or code, and escape "&lt;" and "&amp;" characters <br />      <br />    <br />  <br /> See <br />  <br />    W3C, Obsolete Features  <br />    WHATWG, Obsolete Features  <br /> |BUG|MAJOR|1
"equals" method overrides should accept "Object" parameters|"equals" as a method name should be used exclusively to override Object.equals(Object) to prevent any confusion. <br /> It is tempting to overload the method to take a specific class instead of Object as parameter, to save the class comparison check. <br /> However, this will not work as expected when that is the only override. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />   private int foo = 1; <br />  <br />   public boolean equals(MyClass o) {  // Noncompliant; does not override Object.equals(Object) <br />     return o != null &amp;&amp; o.foo == this.foo; <br />   } <br />  <br />   public static void main(String[] args) { <br />     MyClass o1 = new MyClass(); <br />     Object o2 = new MyClass(); <br />     System.out.println(o1.equals(o2));  // Prints "false" because o2 an Object not a MyClass <br />   } <br /> } <br />  <br /> class MyClass2 { <br />   public boolean equals(MyClass2 o) {  // Ignored; `boolean equals(Object)` also present <br />     //.. <br />   } <br />  <br />   public boolean equals(Object o) { <br />     //... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />   private int foo = 1; <br />  <br />   @Override <br />   public boolean equals(Object o) { <br />     if (this == o) { <br />         return true; <br />     } <br />     if (o == null &#124&#124 getClass() != o.getClass()) { <br />       return false; <br />     } <br />  <br />     MyClass other = (MyClass)o; <br />     return this.foo == other.foo; <br />   } <br />  <br />   /* ... */ <br /> } <br />  <br /> class MyClass2 { <br />   public boolean equals(MyClass2 o) { <br />     //.. <br />   } <br />  <br />   public boolean equals(Object o) { <br />     //... <br />   } <br /> } <br /> |BUG|MAJOR|1
Non-serializable classes should not be written|Nothing in a non-serializable class will be written out to file, and attempting to serialize such a class will result in an exception being thrown. <br /> Only a class that implements Serializable or one that extends such a class can successfully be serialized (or de-serialized).  <br /> Noncompliant Code Example <br />  <br /> public class Vegetable {  // neither implements Serializable nor extends a class that does <br />   //... <br /> } <br />  <br /> public class Menu { <br />   public void meal() throws IOException { <br />     Vegetable veg; <br />     //... <br />     FileOutputStream fout = new FileOutputStream(veg.getName()); <br />     ObjectOutputStream oos = new ObjectOutputStream(fout); <br />     oos.writeObject(veg);  // Noncompliant. Nothing will be written <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Vegetable implements Serializable {  // can now be serialized <br />   //... <br /> } <br />  <br /> public class Menu { <br />   public void meal() throws IOException { <br />     Vegetable veg; <br />     //... <br />     FileOutputStream fout = new FileOutputStream(veg.getName()); <br />     ObjectOutputStream oos = new ObjectOutputStream(fout); <br />     oos.writeObject(veg); <br />   } <br /> } <br /> |BUG|MAJOR|2
"InterruptedException" should not be ignored|InterruptedExceptions should never be ignored in the code, and simply logging the exception counts in this case as "ignoring". The <br /> throwing of the InterruptedException clears the interrupted state of the Thread, so if the exception is not handled properly the fact <br /> that the thread was interrupted will be lost. Instead, InterruptedExceptions should either be rethrown - immediately or after cleaning up <br /> the method's state - or the thread should be re-interrupted by calling Thread.interrupt() even if this is supposed to be a <br /> single-threaded application. Any other course of action risks delaying thread shutdown and loses the information that the thread was interrupted - <br /> probably without finishing its task. <br /> Similarly, the ThreadDeath exception should also be propagated. According to its JavaDoc: <br />  <br />   If ThreadDeath is caught by a method, it is important that it be rethrown so that the thread actually dies. <br />  <br /> Noncompliant Code Example <br />  <br /> public void run () { <br />   try { <br />     while (true) { <br />       // do stuff <br />     } <br />   }catch (InterruptedException e) { // Noncompliant; logging is not enough <br />     LOGGER.log(Level.WARN, "Interrupted!", e); <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void run () { <br />   try { <br />     while (true) { <br />       // do stuff <br />     } <br />   }catch (InterruptedException e) { <br />     LOGGER.log(Level.WARN, "Interrupted!", e); <br />     // Restore interrupted state... <br />     Thread.currentThread().interrupt(); <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-391 - Unchecked Error Condition  <br />    Dealing with InterruptedException  <br /> |BUG|MAJOR|9
Dissimilar primitive wrappers should not be used with the ternary operator without explicit casting|If wrapped primitive values (e.g. Integers and Floats) are used in a ternary operator (e.g. a?b:c), both <br /> values will be unboxed and coerced to a common type, potentially leading to unexpected results. To avoid this, add an explicit cast to a compatible <br /> type. <br /> Noncompliant Code Example <br />  <br /> Integer i = 123456789; <br /> Float f = 1.0f; <br /> Number n = condition ? i : f;  // Noncompliant; i is coerced to float. n = 1.23456792E8 <br />  <br /> Compliant Solution <br />  <br /> Integer i = 123456789; <br /> Float f = 1.0f; <br /> Number n = condition ? (Number) i : f;  // n = 123456789 <br /> |BUG|MAJOR|2
"toString()" and "clone()" methods should not return null|Calling toString() or clone() on an object should always return a string or an object. Returning null <br /> instead contravenes the method's implicit contract. <br /> Noncompliant Code Example <br />  <br /> public String toString () { <br />   if (this.collection.isEmpty()) { <br />     return null; // Noncompliant <br />   } else { <br />     // ... <br />  <br /> Compliant Solution <br />  <br /> public String toString () { <br />   if (this.collection.isEmpty()) { <br />     return ""; <br />   } else { <br />     // ... <br />  <br /> See <br />  <br />    MITRE CWE-476 - NULL Pointer Dereference  <br />    CERT, EXP01-J. - Do not use a null in a case where an object is required <br />    <br /> |BUG|MAJOR|2
Null pointers should not be dereferenced|A reference to null should never be dereferenced/accessed. Doing so will cause a NullPointerException to be thrown. At <br /> best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or <br /> it could allow an attacker to bypass security measures. <br /> Note that when they are present, this rule takes advantage of @CheckForNull and @Nonnull annotations defined in JSR-305 to understand which values are and are not nullable except when @Nonnull is used <br /> on the parameter to equals, which by contract should always work with null. <br /> Noncompliant Code Example <br />  <br /> @CheckForNull <br /> String getName(){...} <br />  <br /> public boolean isNameEmpty() { <br />   return getName().length() == 0; // Noncompliant; the result of getName() could be null, but isn't null-checked <br /> } <br />  <br />  <br /> Connection conn = null; <br /> Statement stmt = null; <br /> try{ <br />   conn = DriverManager.getConnection(DB_URL,USER,PASS); <br />   stmt = conn.createStatement(); <br />   // ... <br />  <br /> }catch(Exception e){ <br />   e.printStackTrace(); <br /> }finally{ <br />   stmt.close();   // Noncompliant; stmt could be null if an exception was thrown in the try{} block <br />   conn.close();  // Noncompliant; conn could be null if an exception was thrown <br /> } <br />  <br />  <br /> private void merge(@Nonnull Color firstColor, @Nonnull Color secondColor){...} <br />  <br /> public  void append(@CheckForNull Color color) { <br />     merge(currentColor, color);  // Noncompliant; color should be null-checked because merge(...) doesn't accept nullable parameters <br /> } <br />  <br />  <br /> void paint(Color color) { <br />   if(color == null) { <br />     System.out.println("Unable to apply color " + color.toString());  // Noncompliant; NullPointerException will be thrown <br />     return; <br />   } <br />   ... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-476 - NULL Pointer Dereference  <br />    CERT, EXP34-C. - Do not dereference null pointers  <br />    CERT, EXP01-J. - Do not use a null in a case where an object is required <br />    <br /> |BUG|MAJOR|26
"notifyAll" should be used|notify and notifyAll both wake up sleeping threads, but notify only rouses one, while notifyAll <br /> rouses all of them. Since notify might not wake up the right thread, notifyAll should be used instead. <br /> Noncompliant Code Example <br />  <br /> class MyThread extends Thread{ <br />  <br />   @Override <br />   public void run(){ <br />     synchronized(this){ <br />       // ... <br />       notify();  // Noncompliant <br />     } <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyThread extends Thread{ <br />  <br />   @Override <br />   public void run(){ <br />     synchronized(this){ <br />       // ... <br />       notifyAll(); <br />     } <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, THI02-J. - Notify all waiting threads rather than a single thread <br />    <br /> |BUG|MAJOR|1
Conditionally executed blocks should be reachable|Conditional expressions which are always true or false can lead to dead code. Such code is always buggy and should never <br /> be used in production. <br /> Noncompliant Code Example <br />  <br /> a = false; <br /> if (a) { // Noncompliant <br />   doSomething(); // never executed <br /> } <br />  <br /> if (!a &#124&#124 b) { // Noncompliant; "!a" is always "true", "b" is never evaluated <br />   doSomething(); <br /> } else { <br />   doSomethingElse(); // never executed <br /> } <br />  <br /> Exceptions <br /> This rule will not raise an issue in either of these cases: <br />  <br />    When the condition is a single final boolean  <br />  <br />  <br /> final boolean debug = false; <br /> //... <br /> if (debug) { <br />   // Print something <br /> } <br />  <br />  <br />    When the condition is literally true or false.  <br />  <br />  <br /> if (true) { <br />   // do something <br /> } <br />  <br /> In these cases it is obvious the code is as intended. <br /> See <br />  <br />    MITRE, CWE-570 - Expression is Always False  <br />    MITRE, CWE-571 - Expression is Always True  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /> |BUG|MAJOR|28
Non-thread-safe fields should not be static|Not all classes in the standard Java library were written to be thread-safe. Using them in a multi-threaded manner is highly likely to cause data <br /> problems or exceptions at runtime. <br /> This rule raises an issue when an instance of Calendar, DateFormat, javax.xml.xpath.XPath, or <br /> javax.xml.validation.SchemaFactory is marked static. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   private static SimpleDateFormat format = new SimpleDateFormat("HH-mm-ss");  // Noncompliant <br />   private static Calendar calendar = Calendar.getInstance();  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   private SimpleDateFormat format = new SimpleDateFormat("HH-mm-ss"); <br />   private Calendar calendar = Calendar.getInstance(); <br /> |BUG|MAJOR|2
Strings and Boxed types should be compared using "equals()"|It's almost always a mistake to compare two instances of java.lang.String or boxed types like java.lang.Integer using <br /> reference equality == or !=, because it is not comparing actual value but locations in memory. <br /> Noncompliant Code Example <br />  <br /> String firstName = getFirstName(); // String overrides equals <br /> String lastName = getLastName(); <br />  <br /> if (firstName == lastName) { ... }; // Non-compliant; false even if the strings have the same value <br />  <br /> Compliant Solution <br />  <br /> String firstName = getFirstName(); <br /> String lastName = getLastName(); <br />  <br /> if (firstName != null &amp;&amp; firstName.equals(lastName)) { ... }; <br />  <br /> See <br />  <br />    MITRE, CWE-595 - Comparison of Object References Instead of Object Contents  <br />    MITRE, CWE-597 - Use of Wrong Operator in String Comparison  <br />    CERT, EXP03-J. - Do not use the equality operators when comparing values of <br />   boxed primitives  <br />    CERT, EXP50-J. - Do not confuse abstract object equality with reference <br />   equality  <br /> |BUG|MAJOR|15
"equals(Object obj)" and "hashCode()" should be overridden in pairs|According to the Java Language Specification, there is a contract between equals(Object) and hashCode(): <br />  <br />   If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two <br />   objects must produce the same integer result.  <br />   It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the <br />   hashCode method on each of the two objects must produce distinct integer results. <br />   However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of <br />   hashtables. <br />  <br /> In order to comply with this contract, those methods should be either both inherited, or both overridden. <br /> Noncompliant Code Example <br />  <br /> class MyClass {    // Noncompliant - should also override "hashCode()" <br />  <br />   @Override <br />   public boolean equals(Object obj) { <br />     /* ... */ <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass {    // Compliant <br />  <br />   @Override <br />   public boolean equals(Object obj) { <br />     /* ... */ <br />   } <br />  <br />   @Override <br />   public int hashCode() { <br />     /* ... */ <br />   } <br />  <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-581 - Object Model Violation: Just One of Equals and Hashcode Defined <br />    <br />    CERT, MET09-J. - Classes that define an equals() method must also define a <br />   hashCode() method  <br /> |BUG|MINOR|10
"Serializable" inner classes of non-serializable classes should be "static"|Serializing a non-static inner class will result in an attempt at serializing the outer class as well. If the outer class is not <br /> serializable, then serialization will fail, resulting in a runtime error.  <br /> Making the inner class static (i.e. "nested") avoids this problem, therefore inner classes should be static if possible. <br /> However, you should be aware that there are semantic differences between an inner class and a nested one:  <br />  <br />    an inner class can only be instantiated within the context of an instance of the outer class.  <br />    a nested (static) class can be instantiated independently of the outer class.  <br />  <br /> Noncompliant Code Example <br />  <br /> public class Pomegranate { <br />   // ... <br />  <br />   public class Seed implements Serializable {  // Noncompliant; serialization will fail <br />     // ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Pomegranate { <br />   // ... <br />  <br />   public static class Seed implements Serializable { <br />     // ... <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT SER05-J. - Do not serialize instances of inner classes  <br /> |BUG|MINOR|1
"equals(Object obj)" should test argument type|Because the equals method takes a generic Object as a parameter, any type of object may be passed to it. The method <br /> should not assume it will only be used to test objects of its class type. It must instead check the parameter's type. <br /> Noncompliant Code Example <br />  <br /> public boolean equals(Object obj) { <br />   MyClass mc = (MyClass)obj;  // Noncompliant <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public boolean equals(Object obj) { <br />   if (obj == null) <br />     return false; <br />  <br />   if (this.getClass() != obj.getClass()) <br />     return false; <br />  <br />   MyClass mc = (MyClass)obj; <br />   // ... <br /> } <br /> |BUG|MINOR|1
Boxing and unboxing should not be immediately reversed|Boxing is the process of putting a primitive value into an analogous object, such as creating an Integer to hold an int <br /> value. Unboxing is the process of retrieving the primitive value from such an object. <br /> Since the original value is unchanged during boxing and unboxing, there's no point in doing either when not needed. This also applies to autoboxing <br /> and auto-unboxing (when Java implicitly handles the primitive/object transition for you). <br /> Noncompliant Code Example <br />  <br /> public void examineInt(int a) { <br />   //... <br /> } <br />  <br /> public void examineInteger(Integer a) { <br />   // ... <br /> } <br />  <br /> public void func() { <br />   int i = 0; <br />   Integer iger1 = Integer.valueOf(0); <br />   double d = 1.0; <br />  <br />   int dIntValue = new Double(d).intValue(); // Noncompliant <br />  <br />   examineInt(new Integer(i).intValue()); // Noncompliant; explicit box/unbox <br />   examineInt(Integer.valueOf(i));  // Noncompliant; boxed int will be auto-unboxed <br />  <br />   examineInteger(i); // Compliant; value is boxed but not then unboxed <br />   examineInteger(iger1.intValue()); // Noncompliant; unboxed int will be autoboxed <br />  <br />   Integer iger2 = new Integer(iger1); // Noncompliant; unnecessary unboxing, value can be reused <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void examineInt(int a) { <br />   //... <br /> } <br />  <br /> public void examineInteger(Integer a) { <br />   // ... <br /> } <br />  <br /> public void func() { <br />   int i = 0; <br />   Integer iger1 = Integer.valueOf(0); <br />   double d = 1.0; <br />  <br />   int dIntValue = (int) d; <br />  <br />   examineInt(i); <br />  <br />   examineInteger(i); <br />   examineInteger(iger1); <br /> } <br /> |BUG|MINOR|26
Math operands should be cast before assignment|When arithmetic is performed on integers, the result will always be an integer. You can assign that result to a long, <br /> double, or float with automatic type conversion, but having started as an int or long, the result <br /> will likely not be what you expect.  <br /> For instance, if the result of int division is assigned to a floating-point variable, precision will have been lost before the <br /> assignment. Likewise, if the result of multiplication is assigned to a long, it may have already overflowed before the assignment. <br /> In either case, the result will not be what was expected. Instead, at least one operand should be cast or promoted to the final type before the <br /> operation takes place. <br /> Noncompliant Code Example <br />  <br /> float twoThirds = 2/3; // Noncompliant; int division. Yields 0.0 <br /> long millisInYear = 1_000*3_600*24*365; // Noncompliant; int multiplication. Yields 1471228928 <br /> long bigNum = Integer.MAX_VALUE + 2; // Noncompliant. Yields -2147483647 <br /> long bigNegNum =  Integer.MIN_VALUE-1; //Noncompliant, gives a positive result instead of a negative one. <br /> Date myDate = new Date(seconds * 1_000); //Noncompliant, won't produce the expected result if seconds &gt; 2_147_483 <br /> ... <br /> public long compute(int factor){ <br />   return factor * 10_000;  //Noncompliant, won't produce the expected result if factor &gt; 214_748 <br /> } <br />  <br /> public float compute2(long factor){ <br />   return factor / 123;  //Noncompliant, will be rounded to closest long integer <br /> } <br />  <br /> Compliant Solution <br />  <br /> float twoThirds = 2f/3; // 2 promoted to float. Yields 0.6666667 <br /> long millisInYear = 1_000L*3_600*24*365; // 1000 promoted to long. Yields 31_536_000_000 <br /> long bigNum = Integer.MAX_VALUE + 2L; // 2 promoted to long. Yields 2_147_483_649 <br /> long bigNegNum =  Integer.MIN_VALUE-1L; // Yields -2_147_483_649 <br /> Date myDate = new Date(seconds * 1_000L); <br /> ... <br /> public long compute(int factor){ <br />   return factor * 10_000L; <br /> } <br />  <br /> public float compute2(long factor){ <br />   return factor / 123f; <br /> } <br />  <br /> or <br />  <br /> float twoThirds = (float)2/3; // 2 cast to float <br /> long millisInYear = (long)1_000*3_600*24*365; // 1_000 cast to long <br /> long bigNum = (long)Integer.MAX_VALUE + 2; <br /> long bigNegNum =  (long)Integer.MIN_VALUE-1; <br /> Date myDate = new Date((long)seconds * 1_000); <br /> ... <br /> public long compute(long factor){ <br />   return factor * 10_000; <br /> } <br />  <br /> public float compute2(float factor){ <br />   return factor / 123; <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-190 - Integer Overflow or Wraparound  <br />    CERT, NUM50-J. - Convert integers to floating point for floating-point <br />   operations  <br />    CERT, INT18-C. - Evaluate integer expressions in a larger size before <br />   comparing or assigning to that size  <br />    SANS Top 25 - Risky Resource Management  <br /> |BUG|MINOR|6
"@NonNull" values should not be set to null|Fields, parameters and return values marked @NotNull, @NonNull, or @Nonnull are assumed to have non-null <br /> values and are not typically null-checked before use. Therefore setting one of these values to null, or failing to set such a class field <br /> in a constructor, could cause NullPointerExceptions at runtime. <br /> Noncompliant Code Example <br />  <br /> public class MainClass { <br />  <br />   @Nonnull <br />   private String primary; <br />   private String secondary; <br />  <br />   public MainClass(String color) { <br />     if (color != null) { <br />       secondary = null; <br />     } <br />     primary = color;  // Noncompliant; "primary" is Nonnull but could be set to null here <br />   } <br />  <br />   public MainClass() { // Noncompliant; "primary" Nonnull" but is not initialized <br />   } <br />  <br />   @Nonnull <br />   public String indirectMix() { <br />     String mix = null; <br />     return mix;  // Noncompliant; return value is Nonnull, but null is returned.}} <br />   } <br />  <br /> See <br />  <br />    MITRE CWE-476 - NULL Pointer Dereference  <br />    CERT, EXP01-J. - Do not use a null in a case where an object is required <br />    <br /> |BUG|MINOR|2
Non-primitive fields should not be "volatile"|Marking an array volatile means that the array itself will always be read fresh and never thread cached, but the items in the <br /> array will not be. Similarly, marking a mutable object field volatile means the object reference is volatile but <br /> the object itself is not, and other threads may not see updates to the object state. <br /> This can be salvaged with arrays by using the relevant AtomicArray class, such as AtomicIntegerArray, instead. For mutable objects, <br /> the volatile should be removed, and some other method should be used to ensure thread-safety, such as synchronization, or ThreadLocal <br /> storage. <br /> Noncompliant Code Example <br />  <br /> private volatile int [] vInts;  // Noncompliant <br /> private volatile MyObj myObj;  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> private AtomicIntegerArray vInts; <br /> private MyObj myObj; <br />  <br /> See <br />  <br />    CERT, CON50-J. - Do not assume that declaring a reference volatile <br />   guarantees safe publication of the members of the referenced object  <br /> |BUG|MINOR|2
"switch" statements should not contain non-case labels|Even if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing <br /> error. <br /> Noncompliant Code Example <br />  <br /> switch (day) { <br />   case MONDAY: <br />   case TUESDAY: <br />   WEDNESDAY:   // Noncompliant; syntactically correct, but behavior is not what's expected <br />     doSomething(); <br />     break; <br />   ... <br /> } <br />  <br /> switch (day) { <br />   case MONDAY: <br />     break; <br />   case TUESDAY: <br />     foo:for(int i = 0 ; i &lt; X ; i++) {  // Noncompliant; the code is correct and behaves as expected but is barely readable <br />          /* ... */ <br />         break foo;  // this break statement doesn't relate to the nesting case TUESDAY <br />          /* ... */ <br />     } <br />     break; <br />     /* ... */ <br /> } <br />  <br /> Compliant Solution <br />  <br /> switch (day) { <br />   case MONDAY: <br />   case TUESDAY: <br />   case WEDNESDAY: <br />     doSomething(); <br />     break; <br />   ... <br /> } <br />  <br /> switch (day) { <br />   case MONDAY: <br />     break; <br />   case TUESDAY: <br />     compute(args); // put the content of the labelled "for" statement in a dedicated method <br />     break; <br />  <br />     /* ... */ <br /> } <br /> |CODE_SMELL|BLOCKER|3
Switch cases should end with an unconditional "break" statement|When the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While <br /> this is sometimes intentional, it often is a mistake which leads to unexpected behavior.  <br /> Noncompliant Code Example <br />  <br /> switch (myVariable) { <br />   case 1: <br />     foo(); <br />     break; <br />   case 2:  // Both 'doSomething()' and 'doSomethingElse()' will be executed. Is it on purpose ? <br />     doSomething(); <br />   default: <br />     doSomethingElse(); <br />     break; <br /> } <br />  <br /> Compliant Solution <br />  <br /> switch (myVariable) { <br />   case 1: <br />     foo(); <br />     break; <br />   case 2: <br />     doSomething(); <br />     break; <br />   default: <br />     doSomethingElse(); <br />     break; <br /> } <br />  <br /> Exceptions <br /> This rule is relaxed in the following cases: <br />  <br /> switch (myVariable) { <br />   case 0:                                // Empty case used to specify the same behavior for a group of cases. <br />   case 1: <br />     doSomething(); <br />     break; <br />   case 2:                                // Use of return statement <br />     return; <br />   case 3:                                // Use of throw statement <br />     throw new IllegalStateException(); <br />   case 4:                                // Use of continue statement <br />     continue; <br />   default:                               // For the last case, use of break statement is optional <br />     doSomethingElse(); <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-484 - Omitted Break Statement in Switch  <br />    CERT, MSC17-C. - Finish every set of statements associated with a case <br />   label with a break statement  <br />    CERT, MSC52-J. - Finish every set of statements associated with a case <br />   label with a break statement  <br /> |CODE_SMELL|BLOCKER|3
Methods and field names should not be the same or differ only by capitalization|Looking at the set of methods in a class, including superclass methods, and finding two methods or fields that differ only by capitalization is <br /> confusing to users of the class. It is similarly confusing to have a method and a field which differ only in capitalization or a method and a field <br /> with exactly the same name and visibility. <br /> In the case of methods, it may have been a mistake on the part of the original developer, who intended to override a superclass method, but instead <br /> added a new method with nearly the same name. <br /> Otherwise, this situation simply indicates poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the <br /> case where both a method and a member have the same name (with or without capitalization differences). However, renaming a public method could be <br /> disruptive to callers. Therefore renaming the member is the recommended action. <br /> Noncompliant Code Example <br />  <br /> public class Car{ <br />  <br />   public DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // Noncompliant; duplicates field name <br /> } <br />  <br /> public class MyCar extends Car{ <br />   public void teardown(){...}  // Noncompliant; not an override. It it really what's intended? <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveFast(){...} //Huh? <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Car{ <br />  <br />   private DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // field visibility reduced <br /> } <br />  <br /> public class MyCar extends Car{ <br />   @Override <br />   public void tearDown(){...} <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveReallyFast(){...} <br />  <br /> } <br /> |CODE_SMELL|BLOCKER|7
Child class fields should not shadow parent class fields|Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you'll get confusion at <br /> best, chaos at worst.  <br /> Noncompliant Code Example <br />  <br /> public class Fruit { <br />   protected Season ripe; <br />   protected Color flesh; <br />  <br />   // ... <br /> } <br />  <br /> public class Raspberry extends Fruit { <br />   private boolean ripe;  // Noncompliant <br />   private static Color FLESH; // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Fruit { <br />   protected Season ripe; <br />   protected Color flesh; <br />  <br />   // ... <br /> } <br />  <br /> public class Raspberry extends Fruit { <br />   private boolean ripened; <br />   private static Color FLESH_COLOR; <br />  <br /> } <br />  <br /> Exceptions <br /> This rule ignores same-name fields that are static in both the parent and child classes. This rule ignores private parent <br /> class fields, but in all other such cases, the child class field should be renamed. <br />  <br /> public class Fruit { <br />   private Season ripe; <br />   // ... <br /> } <br />  <br /> public class Raspberry extends Fruit { <br />   private Season ripe;  // Compliant as parent field 'ripe' is anyway not visible from Raspberry <br />   // ... <br /> } <br /> |CODE_SMELL|BLOCKER|11
"ThreadGroup" should not be used|There is little valid reason to use the methods of the ThreadGroup class. Some are deprecated (allowThreadSuspension(), <br /> resume(), stop(), and suspend()), some are obsolete, others aren't thread-safe, and still others are insecure <br /> (activeCount(), enumerate()) . For these reasons, any use of ThreadGroup is suspicious and should be <br /> avoided. <br /> Compliant Solution <br />  <br /> ThreadFactory threadFactory = Executors.defaultThreadFactory(); <br /> ThreadPoolExecutor executorPool = new ThreadPoolExecutor(3, 10, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), threadFactory); <br />  <br /> for (int i = 0; i &lt; 10; i++) { <br />   executorPool.execute(new JobThread("Job: " + i)); <br /> } <br />  <br /> System.out.println(executorPool.getActiveCount()); // Compliant <br /> executorPool.shutdown(); <br />  <br /> See <br />  <br />    CERT, THI01-J. - Do not invoke ThreadGroup methods  <br /> |CODE_SMELL|BLOCKER|1
Methods returns should not be invariant|When a method is designed to return an invariant value, it may be poor design, but it shouldn't adversely affect the outcome of your program. <br /> However, when it happens on all paths through the logic, it is surely a bug. <br /> This rule raises an issue when a method contains several return statements that all return the same value. <br /> Noncompliant Code Example <br />  <br /> int foo(int a) { <br />   int b = 12; <br />   if (a == 1) { <br />     return b; <br />   } <br />   return b;  // Noncompliant <br /> } <br /> |CODE_SMELL|BLOCKER|1
The Object.finalize() method should not be overriden|The Object.finalize() method is called on an object by the garbage collector when it determines that there are no more references to <br /> the object. But there is absolutely no warranty that this method will be called AS SOON AS the last references to the object are removed. It can be <br /> few microseconds to few minutes later. So when system resources need to be disposed by an object, it's better to not rely on this asynchronous <br /> mechanism to dispose them. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   ... <br />   protected void finalize() { <br />     releaseSomeResources();    // Noncompliant <br />   } <br />   ... <br /> } <br />  <br /> See <br />  <br />    CERT, MET12-J. - Do not use finalizers  <br /> |CODE_SMELL|CRITICAL|3
Constant names should comply with a naming convention|Shared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$: <br />  <br /> public class MyClass { <br />   public static final int first = 1; <br /> } <br />  <br /> public enum MyEnum { <br />   first; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   public static final int FIRST = 1; <br /> } <br />  <br /> public enum MyEnum { <br />   FIRST; <br /> } <br /> |CODE_SMELL|CRITICAL|26
Methods should not be empty|There are several reasons for a method not to have a method body: <br />  <br />    It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production.  <br />    It is not yet, or never will be, supported. In this case an UnsupportedOperationException should be thrown.  <br />    The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.  <br />  <br /> Noncompliant Code Example <br />  <br /> public void doSomething() { <br /> } <br />  <br /> public void doSomethingElse() { <br /> } <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public void doSomething() { <br />   // Do nothing because of X and Y. <br /> } <br />  <br /> @Override <br /> public void doSomethingElse() { <br />   throw new UnsupportedOperationException(); <br /> } <br />  <br /> Exceptions <br /> Default (no-argument) constructors are ignored when there are other constructors in the class, as are empty methods in abstract classes. <br />  <br /> public abstract class Animal { <br />   void speak() {  // default implementation ignored <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|79
String literals should not be duplicated|Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences. <br /> On the other hand, constants can be referenced from many places, but only need to be updated in a single place. <br /> Noncompliant Code Example <br /> With the default threshold of 3: <br />  <br /> public void run() { <br />   prepare("action1");                              // Noncompliant - "action1" is duplicated 3 times <br />   execute("action1"); <br />   release("action1"); <br /> } <br />  <br /> @SuppressWarning("all")                            // Compliant - annotations are excluded <br /> private void method1() { /* ... */ } <br /> @SuppressWarning("all") <br /> private void method2() { /* ... */ } <br />  <br /> public String method3(String a) { <br />   System.out.println("'" + a + "'");               // Compliant - literal "'" has less than 5 characters and is excluded <br />   return "";                                       // Compliant - literal "" has less than 5 characters and is excluded <br /> } <br />  <br /> Compliant Solution <br />  <br /> private static final String ACTION_1 = "action1";  // Compliant <br />  <br /> public void run() { <br />   prepare(ACTION_1);                               // Compliant <br />   execute(ACTION_1); <br />   release(ACTION_1); <br /> } <br />  <br /> Exceptions <br /> To prevent generating some false-positives, literals having less than 5 characters are excluded.|CODE_SMELL|CRITICAL|186
Constants should not be defined in interfaces|According to Joshua Bloch, author of "Effective Java": <br />  <br />   The constant interface pattern is a poor use of interfaces.  <br />   That a class uses some constants internally is an implementation detail. <br />   Implementing a constant interface causes this implementation detail to leak into the class's exported API. It is of no consequence to the users <br />   of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future <br />   release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. <br />   If a nonfinal class implements a constant interface, <br />   all of its subclasses will have their namespaces polluted by the constants in the interface. <br />  <br /> Noncompliant Code Example <br />  <br /> interface Status {                      // Noncompliant <br />    int OPEN = 1; <br />    int CLOSED = 2; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public enum Status {                    // Compliant <br />   OPEN, <br />   CLOSED; <br /> } <br />  <br /> or <br />  <br /> public final class Status {             // Compliant <br />    public static final int OPEN = 1; <br />    public static final int CLOSED = 2; <br /> } <br /> |CODE_SMELL|CRITICAL|5
Execution of the Garbage Collector should be triggered only by the JVM|Calling System.gc() or Runtime.getRuntime().gc() is a bad idea for a simple reason: there is no way to know exactly what <br /> will be done under the hood by the JVM because the behavior will depend on its vendor, version and options: <br />  <br />    Will the whole application be frozen during the call?  <br />    Is the -XX:DisableExplicitGC option activated?  <br />    Will the JVM simply ignore the call?  <br />    ...  <br />  <br /> An application relying on these unpredictable methods is also unpredictable and therefore broken. The task of running the garbage collector should <br /> be left exclusively to the JVM.|CODE_SMELL|CRITICAL|1
Fields in a "Serializable" class should either be transient or serializable|Fields in a Serializable class must themselves be either Serializable or transient even if the class is <br /> never explicitly serialized or deserialized. For instance, under load, most J2EE application frameworks flush objects to disk, and an allegedly <br /> Serializable object with non-transient, non-serializable data members could cause program crashes, and open the door to attackers. In <br /> general a Serializable class is expected to fulfil its contract and not have an unexpected behaviour when an instance is serialized.  <br /> This rule raises an issue on non-Serializable fields, and on collection fields when they are not private (because they <br /> could be assigned non-Serializable values externally), and when they are assigned non-Serializable types within the <br /> class. <br /> Noncompliant Code Example <br />  <br /> public class Address { <br />   //... <br /> } <br />  <br /> public class Person implements Serializable { <br />   private static final long serialVersionUID = 1905122041950251207L; <br />  <br />   private String name; <br />   private Address address;  // Noncompliant; Address isn't serializable <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Address implements Serializable { <br />   private static final long serialVersionUID = 2405172041950251807L; <br /> } <br />  <br /> public class Person implements Serializable { <br />   private static final long serialVersionUID = 1905122041950251207L; <br />  <br />   private String name; <br />   private Address address; <br /> } <br />  <br /> Exceptions <br /> The alternative to making all members serializable or transient is to implement special methods which take on the <br /> responsibility of properly serializing and de-serializing the object. This rule ignores classes which implement the following methods: <br />  <br />  private void writeObject(java.io.ObjectOutputStream out) <br />      throws IOException <br />  private void readObject(java.io.ObjectInputStream in) <br />      throws IOException, ClassNotFoundException; <br />  <br /> See <br />  <br />    MITRE, CWE-594 - Saving Unserializable Objects to Disk  <br />    Oracle Java 6, Serializable  <br />    Oracle Java 7, Serializable  <br /> |CODE_SMELL|CRITICAL|69
"for" loop increment clauses should modify the loops' counters|It can be extremely confusing when a for loop's counter is incremented outside of its increment clause. In such cases, the increment <br /> should be moved to the loop's increment clause if at all possible. <br /> Noncompliant Code Example <br />  <br /> for (i = 0; i &lt; 10; j++) { // Noncompliant <br />   // ... <br />   i++; <br /> } <br />  <br /> Compliant Solution <br />  <br /> for (i = 0; i &lt; 10; i++, j++) { <br />   // ... <br /> } <br />  <br /> Or  <br />  <br /> for (i = 0; i &lt; 10; i++) { <br />   // ... <br />   j++; <br /> } <br /> |CODE_SMELL|CRITICAL|1
Try-with-resources should be used|Java 7 introduced the try-with-resources statement, which guarantees that the resource in question will be closed. Since the new syntax is closer <br /> to bullet-proof, it should be preferred over the older try/catch/finally version. <br /> This rule checks that close-able resources are opened in a try-with-resources statement. <br /> Note that this rule is automatically disabled when the project's sonar.java.source is lower than 7. <br /> Noncompliant Code Example <br />  <br /> FileReader fr = null; <br /> BufferedReader br = null; <br /> try { <br />   fr = new FileReader(fileName); <br />   br = new BufferedReader(fr); <br />   return br.readLine(); <br /> } catch (...) { <br /> } finally { <br />   if (br != null) { <br />     try { <br />       br.close(); <br />     } catch(IOException e){...} <br />   } <br />   if (fr != null ) { <br />     try { <br />       br.close(); <br />     } catch(IOException e){...} <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> try ( <br />     FileReader fr = new FileReader(fileName); <br />     BufferedReader br = new BufferedReader(fr) <br />   ) { <br />   return br.readLine(); <br /> } <br /> catch (...) {} <br />  <br /> or <br />  <br /> try (BufferedReader br = <br />         new BufferedReader(new FileReader(fileName))) { // no need to name intermediate resources if you don't want to <br />   return br.readLine(); <br /> } <br /> catch (...) {} <br />  <br /> See <br />  <br />    CERT, ERR54-J. - Use a try-with-resources statement to safely handle <br />   closeable resources  <br /> |CODE_SMELL|CRITICAL|28
"Object.wait(...)" and "Condition.await(...)" should be called inside a "while" loop|According to the documentation of the Java Condition interface: <br />  <br />   When waiting upon a Condition, a "spurious wakeup" is permitted to occur, in general, as a concession to the underlying platform <br />   semantics. This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state <br />   predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications <br />   programmers always assume that they can occur and so always wait in a loop. <br />  <br /> The same advice is also found for the Object.wait(...) method: <br />  <br />   waits should always occur in loops, like this one: <br />    <br /> synchronized (obj) { <br />   while (&lt;condition does not hold&gt;){ <br />     obj.wait(timeout); <br />   } <br />    ... // Perform action appropriate to condition <br /> } <br />  <br />  <br /> Noncompliant Code Example <br />  <br /> synchronized (obj) { <br />   if (!suitableCondition()){ <br />     obj.wait(timeout);   //the thread can wake up even if the condition is still false <br />   } <br />    ... // Perform action appropriate to condition <br /> } <br />  <br /> Compliant Solution <br />  <br /> synchronized (obj) { <br />   while (!suitableCondition()){ <br />     obj.wait(timeout); <br />   } <br />    ... // Perform action appropriate to condition <br /> } <br />  <br /> See <br />  <br />    CERT THI03-J. - Always invoke wait() and await() methods inside a loop <br />    <br /> |CODE_SMELL|CRITICAL|2
"indexOf" checks should not be for positive numbers|Most checks against an indexOf value compare it with -1 because 0 is a valid index. Any checks which look for values &gt;0 ignore the <br /> first element, which is likely a bug. If the intent is merely to check inclusion of a value in a String or a List, consider <br /> using the contains method instead. <br /> This rule raises an issue when an indexOf value retrieved either from a String or a List is tested against <br /> &gt;0. <br /> Noncompliant Code Example <br />  <br /> String color = "blue"; <br /> String name = "ishmael"; <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;String&gt; (); <br /> strings.add(color); <br /> strings.add(name); <br />  <br /> if (strings.indexOf(color) &gt; 0) {  // Noncompliant <br />   // ... <br /> } <br /> if (name.indexOf("ish") &gt; 0) { // Noncompliant <br />   // ... <br /> } <br /> if (name.indexOf("ae") &gt; 0) { // Noncompliant <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> String color = "blue"; <br /> String name = "ishmael"; <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;String&gt; (); <br /> strings.add(color); <br /> strings.add(name); <br />  <br /> if (strings.indexOf(color) &gt; -1) { <br />   // ... <br /> } <br /> if (name.indexOf("ish") &gt;= 0) { <br />   // ... <br /> } <br /> if (name.contains("ae") { <br />   // ... <br /> } <br /> |CODE_SMELL|CRITICAL|4
Instance methods should not write to "static" fields|Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple <br /> class instances and/or multiple threads in play. Ideally, static fields are only updated from synchronized static <br /> methods. <br /> This rule raises an issue each time a static field is updated from a non-static method. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />  <br />   private static int count = 0; <br />  <br />   public void doSomething() { <br />     //... <br />     count++;  // Noncompliant <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|29
"static" base class members should not be accessed via derived types|In the interest of code clarity, static members of a base class should never be accessed using a derived type's name. <br /> Doing so is confusing and could create the illusion that two different static members exist. <br /> Noncompliant Code Example <br />  <br /> class Parent { <br />   public static int counter; <br /> } <br />  <br /> class Child extends Parent { <br />   public Child() { <br />     Child.counter++;  // Noncompliant <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class Parent { <br />   public static int counter; <br /> } <br />  <br /> class Child extends Parent { <br />   public Child() { <br />     Parent.counter++; <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|8
Cognitive Complexity of methods should not be too high|Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be <br /> difficult to maintain. <br /> See <br />  <br />    Cognitive Complexity  <br /> |CODE_SMELL|CRITICAL|284
A conditionally executed single line should be denoted by indentation|In the absence of enclosing curly braces, the line immediately after a conditional is the one that is conditionally executed. By both convention <br /> and good practice, such lines are indented. In the absence of both curly braces and indentation the intent of the original programmer is entirely <br /> unclear and perhaps not actually what is executed. Additionally, such code is highly likely to be confusing to maintainers. <br /> Noncompliant Code Example <br />  <br /> if (condition)  // Noncompliant <br /> doTheThing(); <br />  <br /> doTheOtherThing(); <br /> somethingElseEntirely(); <br />  <br /> foo(); <br />  <br /> Compliant Solution <br />  <br /> if (condition) <br />   doTheThing(); <br />  <br /> doTheOtherThing(); <br /> somethingElseEntirely(); <br />  <br /> foo(); <br /> |CODE_SMELL|CRITICAL|35
"switch" statements should have "default" clauses|The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a <br /> suitable comment as to why no action is taken. <br /> Noncompliant Code Example <br />  <br /> switch (param) {  //missing default clause <br />   case 0: <br />     doSomething(); <br />     break; <br />   case 1: <br />     doSomethingElse(); <br />     break; <br /> } <br />  <br /> switch (param) { <br />   default: // default clause should be the last one <br />     error(); <br />     break; <br />   case 0: <br />     doSomething(); <br />     break; <br />   case 1: <br />     doSomethingElse(); <br />     break; <br /> } <br />  <br /> Compliant Solution <br />  <br /> switch (param) { <br />   case 0: <br />     doSomething(); <br />     break; <br />   case 1: <br />     doSomethingElse(); <br />     break; <br />   default: <br />     error(); <br />     break; <br /> } <br />  <br /> Exceptions <br /> If the switch parameter is an Enum and if all the constants of this enum are used in the case statements, <br /> then no default clause is expected. <br /> Example: <br />  <br /> public enum Day { <br />     SUNDAY, MONDAY <br /> } <br /> ... <br /> switch(day) { <br />   case SUNDAY: <br />     doSomething(); <br />     break; <br />   case MONDAY: <br />     doSomethingElse(); <br />     break; <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-478 - Missing Default Case in Switch Statement  <br />    CERT, MSC01-C. - Strive for logical completeness  <br /> |CODE_SMELL|CRITICAL|50
Deprecated code should be removed|This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed. <br /> Noncompliant Code Example <br />  <br /> class Foo { <br />   /** <br />    * @deprecated <br />    */ <br />   public void foo() {    // Noncompliant <br />   } <br />  <br />   @Deprecated            // Noncompliant <br />   public void bar() { <br />   } <br />  <br />   public void baz() {    // Compliant <br />   } <br /> } <br /> |CODE_SMELL|INFO|36
Track uses of "TODO" tags|TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later. <br /> Sometimes the developer will not have the time or will simply forget to get back to that tag. <br /> This rule is meant to track those tags and to ensure that they do not go unnoticed. <br /> Noncompliant Code Example <br />  <br /> void doSomething() { <br />   // TODO <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-546 - Suspicious Comment  <br /> |CODE_SMELL|INFO|32
Source files should not have any duplicated blocks|An issue is created on a file as soon as there is at least one block of duplicated code on this file|CODE_SMELL|MAJOR|55
Assignments should not be made from within sub-expressions|Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have <br /> side-effects. <br /> Noncompliant Code Example <br />  <br /> if ((str = cont.substring(pos1, pos2)).isEmpty()) {  // Noncompliant <br />   //... <br />  <br /> Compliant Solution <br />  <br /> str = cont.substring(pos1, pos2); <br /> if (str.isEmpty()) { <br />   //... <br />  <br /> Exceptions <br /> Assignments in while statement conditions, and assignments enclosed in relational expressions are ignored. <br />  <br /> BufferedReader br = new BufferedReader(/* ... */); <br /> String line; <br /> while ((line = br.readLine()) != null) {...} <br />  <br /> Chained assignments, including compound assignments, are ignored. <br />  <br /> int i = j = 0; <br /> int k = (j += 1); <br /> result = (bresult = new byte[len]); <br />  <br /> See <br />  <br />    MITRE, CWE-481 - Assigning instead of Comparing  <br />    CERT, EXP45-C. - Do not perform assignments in selection statements  <br />    CERT, EXP51-J. - Do not perform assignments in conditional expressions <br />    <br /> |CODE_SMELL|MAJOR|171
Sections of code should not be commented out|Programmers should not comment out code as it bloats programs and reduces readability. <br /> Unused code should be deleted and can be retrieved from source control history if required.|CODE_SMELL|MAJOR|4220
"for" loop stop conditions should be invariant|A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and <br /> ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.  <br /> Stop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the <br /> introduction of errors in the future. <br /> This rule tracks three types of non-invariant stop conditions: <br />  <br />    When the loop counters are updated in the body of the for loop  <br />    When the stop condition depend upon a method call  <br />    When the stop condition depends on an object property, since such properties could change during the execution of the loop.  <br />  <br /> Noncompliant Code Example <br />  <br /> for (int i = 0; i &lt; 10; i++) { <br />   ... <br />   i = i - 1; // Noncompliant; counter updated in the body of the loop <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> for (int i = 0; i &lt; 10; i++) {...} <br /> |CODE_SMELL|MAJOR|14
Local variables should not shadow class fields|Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of <br /> code. Further, it could lead maintainers to introduce bugs because they think they're using one variable but are really using another. <br /> Noncompliant Code Example <br />  <br /> class Foo { <br />   public int myField; <br />  <br />   public void doSomething() { <br />     int myField = 0; <br />     ... <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, DCL01-C. - Do not reuse <br />   variable names in subscopes  <br />    CERT, DCL51-J. - Do <br />   not shadow or obscure identifiers in subscopes  <br /> |CODE_SMELL|MAJOR|113
Labels should not be used|Labels are not commonly used in Java, and many developers do not understand how they work. Moreover, their usage makes the control flow harder to <br /> follow, which reduces the code's readability. <br /> Noncompliant Code Example <br />  <br /> int matrix[][] = { <br />   {1, 2, 3}, <br />   {4, 5, 6}, <br />   {7, 8, 9} <br /> }; <br />  <br /> outer: for (int row = 0; row &lt; matrix.length; row++) {   // Non-Compliant <br />   for (int col = 0; col &lt; matrix[row].length; col++) { <br />     if (col == row) { <br />       continue outer; <br />     } <br />     System.out.println(matrix[row][col]);                // Prints the elements under the diagonal, i.e. 4, 7 and 8 <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> for (int row = 1; row &lt; matrix.length; row++) {          // Compliant <br />   for (int col = 0; col &lt; row; col++) { <br />     System.out.println(matrix[row][col]);                // Also prints 4, 7 and 8 <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|44
Inheritance tree of classes should not be too deep|Inheritance is certainly one of the most valuable concepts in object-oriented programming. It's a way to compartmentalize and reuse code by <br /> creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating <br /> a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object <br /> oriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better. <br /> This rule raises an issue when the inheritance tree, starting from Object has a greater depth than is allowed. |CODE_SMELL|MAJOR|61
Deprecated elements should have both the annotation and the Javadoc tag|Deprecation should be marked with both the @Deprecated annotation and @deprecated Javadoc tag. The annotation enables tools such as <br /> IDEs to warn about referencing deprecated elements, and the tag can be used to explain when it was deprecated, why, and how references should be <br /> refactored.  <br /> Further, Java 9 adds two additional arguments to the annotation: <br />  <br />    since allows you to describe when the deprecation took place  <br />    forRemoval, indicates whether the deprecated element will be removed at some future date  <br />  <br /> If your compile level is Java 9 or higher, you should be using one or both of these arguments. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />  <br />   @Deprecated <br />   public void foo1() { <br />   } <br />  <br />   /** <br />     * @deprecated <br />     */ <br />   public void foo2() {    // Noncompliant <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />  <br />   /** <br />     * @deprecated (when, why, refactoring advice...) <br />     */ <br />   @Deprecated <br />   public void foo1() { <br />   } <br />  <br />   /** <br />     * Java &gt;= 9 <br />     * @deprecated (when, why, refactoring advice...) <br />     */ <br />   @Deprecated(since="5.1") <br />   public void foo2() { <br />   } <br />  <br />   /** <br />     * Java &gt;= 9 <br />     * @deprecated (when, why, refactoring advice...) <br />     */ <br />   @Deprecated(since="4.2", forRemoval=true) <br />   public void foo3() { <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> The members and methods of a deprecated class or interface are ignored by this rule. The classes and interfaces themselves are still subject to <br /> it. <br />  <br /> /** <br />  * @deprecated (when, why, etc...) <br />  */ <br /> @Deprecated <br /> class Qix  { <br />  <br />   public void foo() {} // Compliant; class is deprecated <br />  <br /> } <br />  <br /> /** <br />  * @deprecated (when, why, etc...) <br />  */ <br /> @Deprecated <br /> interface Plop { <br />  <br />   void bar(); <br />  <br /> } <br /> |CODE_SMELL|MAJOR|26
Methods should not have too many parameters|A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many <br /> things. <br /> Noncompliant Code Example <br /> With a maximum number of 4 parameters: <br />  <br /> public void doSomething(int param1, int param2, int param3, String param4, long param5) { <br /> ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(int param1, int param2, int param3, String param4) { <br /> ... <br /> } <br />  <br /> Exceptions <br /> Methods annotated with Spring's @RequestMapping (and related shortcut annotations, like @GetRequest) or <br /> @JsonCreator may have a lot of parameters, encapsulation being possible. Such methods are therefore ignored.|CODE_SMELL|MAJOR|11
Nested blocks of code should not be left empty|Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed. <br /> Noncompliant Code Example <br />  <br /> for (int i = 0; i &lt; 42; i++){}  // Empty on purpose or missing piece of code ? <br />  <br /> Exceptions <br /> When a block contains a comment, this block is not considered to be empty unless it is a synchronized block. synchronized <br /> blocks are still considered empty even with comments because they can still affect program flow.|CODE_SMELL|MAJOR|43
Generic exceptions should never be thrown|Using such generic exceptions as Error, RuntimeException, Throwable, and Exception prevents <br /> calling methods from handling true, system-generated exceptions differently than application-generated errors.  <br /> Noncompliant Code Example <br />  <br /> public void foo(String bar) throws Throwable {  // Noncompliant <br />   throw new RuntimeException("My Message");     // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void foo(String bar) { <br />   throw new MyOwnRuntimeException("My Message"); <br /> } <br />  <br /> Exceptions <br /> Generic exceptions in the signatures of overriding methods are ignored, because overriding method has to follow signature of the throw declaration <br /> in the superclass. The issue will be raised on superclass declaration of the method (or won't be raised at all if superclass is not part of the <br /> analysis). <br />  <br /> @Override <br /> public void myMethod() throws Exception {...} <br />  <br /> Generic exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions. <br />  <br /> public void myOtherMethod throws Exception { <br />   doTheThing();  // this method throws Exception <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-397 - Declaration of Throws for Generic Exception  <br />    CERT, ERR07-J. - Do not throw RuntimeException, Exception, or Throwable <br />    <br /> |CODE_SMELL|MAJOR|43
Standard outputs should not be used directly to log anything|When logging a message there are several important requirements which must be fulfilled: <br />  <br />    The user must be able to easily retrieve the logs  <br />    The format of all logged message must be uniform to allow the user to easily read the log  <br />    Logged data must actually be recorded  <br />    Sensitive data must only be logged securely  <br />  <br /> If a program directly writes to the standard outputs, there is absolutely no way to comply with those requirements. That's why defining and using a <br /> dedicated logger is highly recommended. <br /> Noncompliant Code Example <br />  <br /> System.out.println("My Message");  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> logger.log("My Message"); <br />  <br /> See <br />  <br />    CERT, ERR02-J. - Prevent exceptions while logging data  <br /> |CODE_SMELL|MAJOR|93
Unused labels should be removed|If a label is declared but not used in the program, it can be considered as dead code and should therefore be removed. <br /> This will improve maintainability as developers will not wonder what this label is used for. <br /> Noncompliant Code Example <br />  <br /> void foo() { <br />   outer: //label is not used. <br />   for(int i = 0; i&lt;10; i++) { <br />     break; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> void foo() { <br />   for(int i = 0; i&lt;10; i++) { <br />     break; <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /> |CODE_SMELL|MAJOR|3
Collapsible "if" statements should be merged|Merging collapsible if statements increases the code's readability. <br /> Noncompliant Code Example <br />  <br /> if (file != null) { <br />   if (file.isFile() &#124&#124 file.isDirectory()) { <br />     /* ... */ <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (file != null &amp;&amp; isFileOrDirectory(file)) { <br />   /* ... */ <br /> } <br />  <br /> private static boolean isFileOrDirectory(File file) { <br />   return file.isFile() &#124&#124 file.isDirectory(); <br /> } <br /> |CODE_SMELL|MAJOR|52
Unused "private" fields should be removed|If a private field is declared but not used in the program, it can be considered dead code and should therefore be removed. This will <br /> improve maintainability because developers will not wonder what the variable is used for. <br /> Note that this rule does not take reflection into account, which means that issues will be raised on private fields that are only <br /> accessed using the reflection API. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   private int foo = 42; <br />  <br />   public int compute(int a) { <br />     return a * 42; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   public int compute(int a) { <br />     return a * 42; <br />   } <br /> } <br />  <br /> Exceptions <br /> The Java serialization runtime associates with each serializable class a version number, called serialVersionUID, which is used during <br /> deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to <br /> serialization. <br /> A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that <br /> must be static, final, and of type long. By definition those serialVersionUID fields should not be reported by this rule: <br />  <br /> public class MyClass implements java.io.Serializable { <br />   private static final long serialVersionUID = 42L; <br /> } <br />  <br /> Moreover, this rule doesn't raise any issue on annotated fields.|CODE_SMELL|MAJOR|10
Utility classes should not have public constructors|Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can <br /> be extended, should not have public constructors. <br /> Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor <br /> should be defined. <br /> Noncompliant Code Example <br />  <br /> class StringUtils { // Noncompliant <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class StringUtils { // Compliant <br />  <br />   private StringUtils() { <br />     throw new IllegalStateException("Utility class"); <br />   } <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> When class contains public static void main(String[] args) method it is not considered as utility class and will be ignored by this <br /> rule.|CODE_SMELL|MAJOR|27
Track uses of "FIXME" tags|FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later. <br /> Sometimes the developer will not have the time or will simply forget to get back to that tag. <br /> This rule is meant to track those tags and to ensure that they do not go unnoticed. <br /> Noncompliant Code Example <br />  <br /> int divide(int numerator, int denominator) { <br />   return numerator / denominator;              // FIXME denominator value might be  0 <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-546 - Suspicious Comment  <br /> |CODE_SMELL|MAJOR|3
Try-catch blocks should not be nested|Nesting try/catch blocks severely impacts the readability of source code because it makes it too difficult to understand <br /> which block will catch which exception.|CODE_SMELL|MAJOR|14
Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used|Early classes of the Java API, such as Vector, Hashtable and StringBuffer, were synchronized to make them <br /> thread-safe. Unfortunately, synchronization has a big negative impact on performance, even when using these collections from a single thread. <br /> It is better to use their new unsynchronized replacements: <br />  <br />    ArrayList or LinkedList instead of Vector  <br />    Deque instead of Stack  <br />    HashMap instead of Hashtable  <br />    StringBuilder instead of StringBuffer  <br />  <br /> Noncompliant Code Example <br />  <br /> Vector cats = new Vector(); <br />  <br /> Compliant Solution <br />  <br /> ArrayList cats = new ArrayList(); <br />  <br /> Exceptions <br /> Use of those synchronized classes is ignored in the signatures of overriding methods. <br />  <br /> @Override <br /> public Vector getCats() {...} <br /> |CODE_SMELL|MAJOR|140
Enumeration should not be implemented|From the official Oracle Javadoc: <br />  <br />   NOTE: The functionality of this Enumeration interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove <br />   operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration. <br />  <br /> Noncompliant Code Example <br />  <br /> public class MyClass implements Enumeration {  // Non-Compliant <br />   /* ... */ <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass implements Iterator {     // Compliant <br />   /* ... */ <br /> } <br /> |CODE_SMELL|MAJOR|1
"@Override" should be used on overriding and implementing methods|Using the @Override annotation is useful for two reasons : <br />  <br />    It elicits a warning from the compiler if the annotated method doesn't actually override anything, as in the case of a misspelling.  <br />    It improves the readability of the source code by making it obvious that methods are overridden.  <br />  <br /> Noncompliant Code Example <br />  <br /> class ParentClass { <br />   public boolean doSomething(){...} <br /> } <br /> class FirstChildClass extends ParentClass { <br />   public boolean doSomething(){...}  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> class ParentClass { <br />   public boolean doSomething(){...} <br /> } <br /> class FirstChildClass extends ParentClass { <br />   @Override <br />   public boolean doSomething(){...}  // Compliant <br /> } <br />  <br /> Exceptions <br /> This rule is relaxed when overriding a method from the Object class like toString(), hashCode(), ...|CODE_SMELL|MAJOR|137
Empty arrays and collections should be returned instead of null|Returning null instead of an actual array or collection forces callers of the method to explicitly test for nullity, making them more <br /> complex and less readable. <br /> Moreover, in many cases, null is used as a synonym for empty. <br /> Noncompliant Code Example <br />  <br /> public static List&lt;Result&gt; getResults() { <br />   return null;                             // Noncompliant <br /> } <br />  <br /> public static Result[] getResults() { <br />   return null;                             // Noncompliant <br /> } <br />  <br /> public static void main(String[] args) { <br />   Result[] results = getResults(); <br />  <br />   if (results != null) {                   // Nullity test required to prevent NPE <br />     for (Result result: results) { <br />       /* ... */ <br />     } <br />   } <br /> } <br />  <br />  <br /> Compliant Solution <br />  <br /> public static List&lt;Result&gt; getResults() { <br />   return Collections.emptyList();          // Compliant <br /> } <br />  <br /> public static Result[] getResults() { <br />   return new Result[0]; <br /> } <br />  <br /> public static void main(String[] args) { <br />   for (Result result: getResults()) { <br />     /* ... */ <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, MSC19-C. - For functions that return an array, prefer returning an <br />   empty array over a null value  <br />    CERT, MET55-J. - Return an empty array or collection instead of a null <br />   value for methods that return an array or collection  <br /> |CODE_SMELL|MAJOR|22
Only static class initializers should be used|Non-static initializers are rarely used, and can be confusing for most developers because they only run when new class instances are created. When <br /> possible, non-static initializers should be refactored into standard constructors or field initializers. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />   private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;String, String&gt;() { <br />  <br />     // Noncompliant - HashMap should be extended only to add behavior, not for initialization <br />     { <br />       put("a", "b"); <br />     } <br />  <br />   }; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />   private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;String, String&gt;(); <br />  <br />   static { <br />     MY_MAP.put("a", "b"); <br />   } <br /> } <br />  <br /> or using Guava: <br />  <br /> class MyClass { <br />   // Compliant <br />   private static final Map&lt;String, String&gt; MY_MAP = ImmutableMap.of("a", "b"); <br /> } <br /> |CODE_SMELL|MAJOR|1
Unused method parameters should be removed|Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same. <br /> Noncompliant Code Example <br />  <br /> void doSomething(int a, int b) {     // "b" is unused <br />   compute(a); <br /> } <br />  <br /> Compliant Solution <br />  <br /> void doSomething(int a) { <br />   compute(a); <br /> } <br />  <br /> Exceptions <br /> The rule will not raise issues for unused parameters: <br />  <br />    that are annotated with @javax.enterprise.event.Observes  <br />    in overrides and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw or that have empty bodies  <br />    in annotated methods, unless the annotation is @SuppressWarning("unchecked") or @SuppressWarning("rawtypes"), in <br />   which case the annotation will be ignored  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the parameter is documented with a proper <br />   javadoc.  <br />  <br />  <br /> @Override <br /> void doSomething(int a, int b) {     // no issue reported on b <br />   compute(a); <br /> } <br />  <br /> public void foo(String s) { <br />   // designed to be extended but noop in standard case <br /> } <br />  <br /> protected void bar(String s) { <br />   //open-closed principle <br /> } <br />  <br /> public void qix(String s) { <br />   throw new UnsupportedOperationException("This method should be implemented in subclasses"); <br /> } <br />  <br /> /** <br />  * @param s This string may be use for further computation in overriding classes <br />  */ <br /> protected void foobar(int a, String s) { // no issue, method is overridable and unused parameter has proper javadoc <br />   compute(a); <br /> } <br />  <br /> See <br />  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /> |CODE_SMELL|MAJOR|23
Throwable and Error should not be caught|Throwable is the superclass of all errors and exceptions in Java. Error is the superclass of all errors, which are not <br /> meant to be caught by applications. <br /> Catching either Throwable or Error will also catch OutOfMemoryError and InternalError, from <br /> which an application should not attempt to recover. <br /> Noncompliant Code Example <br />  <br /> try { /* ... */ } catch (Throwable t) { /* ... */ } <br /> try { /* ... */ } catch (Error e) { /* ... */ } <br />  <br /> Compliant Solution <br />  <br /> try { /* ... */ } catch (RuntimeException e) { /* ... */ } <br /> try { /* ... */ } catch (MyException e) { /* ... */ } <br />  <br /> See <br />  <br />    MITRE, CWE-396 - Declaration of Catch for Generic Exception  <br />    CERT, ERR08-J. - Do not catch NullPointerException or any of its ancestors <br />    <br /> |CODE_SMELL|MAJOR|69
Exception types should not be tested using "instanceof" in catch blocks|Multiple catch blocks of the appropriate type should be used instead of catching a general exception, and then testing on the type. <br /> Noncompliant Code Example <br />  <br /> try { <br />   /* ... */ <br /> } catch (Exception e) { <br />   if(e instanceof IOException) { /* ... */ }         // Noncompliant <br />   if(e instanceof NullPointerException{ /* ... */ }  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> try { <br />   /* ... */ <br /> } catch (IOException e) { /* ... */ }                // Compliant <br /> } catch (NullPointerException e) { /* ... */ }       // Compliant <br />  <br /> See <br />  <br />    CERT, ERR51-J. - Prefer user-defined exceptions over more general exception <br />   types  <br /> |CODE_SMELL|MAJOR|72
"switch" statements should not have too many "case" clauses|When switch statements have large sets of case clauses, it is usually an attempt to map two sets of data. A real map <br /> structure would be more readable and maintainable, and should be used instead. <br /> Exceptions <br /> This rule ignores switches over Enums and empty, fall-through cases.|CODE_SMELL|MAJOR|2
Anonymous inner classes containing only one method should become lambdas|Before Java 8, the only way to partially support closures in Java was by using anonymous inner classes. But the syntax of anonymous classes may <br /> seem unwieldy and unclear. <br /> With Java 8, most uses of anonymous inner classes should be replaced by lambdas to highly increase the readability of the source code. <br /> Note that this rule is automatically disabled when the project's sonar.java.source is lower than 8. <br /> Noncompliant Code Example <br />  <br /> myCollection.stream().map(new Mapper&lt;String,String&gt;() { <br />   public String map(String input) { <br />     return new StringBuilder(input).reverse().toString(); <br />   } <br /> }); <br />  <br /> Predicate&lt;String&gt; isEmpty = new Predicate&lt;String&gt; { <br />     boolean test(String myString) { <br />         return myString.isEmpty(); <br />     } <br /> } <br />  <br /> Compliant Solution <br />  <br /> myCollection.stream().map(input -&gt; new StringBuilder(input).reverse().toString()); <br />  <br /> Predicate&lt;String&gt; isEmpty = myString -&gt; myString.isEmpty(); <br /> |CODE_SMELL|MAJOR|151
A field should not duplicate the name of its containing class|It's confusing to have a class member with the same name (case differences aside) as its enclosing class. This is particularly so when you consider <br /> the common practice of naming a class instance for the class itself. <br /> Best practice dictates that any field or member with the same name as the enclosing class be renamed to be more descriptive of the particular <br /> aspect of the class it represents or holds. <br /> Noncompliant Code Example <br />  <br /> public class Foo { <br />   private String foo; <br />  <br />   public String getFoo() { } <br /> } <br />  <br /> Foo foo = new Foo(); <br /> foo.getFoo() // what does this return? <br />  <br /> Compliant Solution <br />  <br /> public class Foo { <br />   private String name; <br />  <br />   public String getName() { } <br /> } <br />  <br /> //... <br />  <br /> Foo foo = new Foo(); <br /> foo.getName() <br />  <br />  <br /> Exceptions <br /> When the type of the field is the containing class and that field is static, no issue is raised to allow singletons named like the type.  <br />  <br /> public class Foo { <br />   ... <br />   private static Foo foo; <br />   public Foo getInstance() { <br />     if(foo==null) { <br />       foo = new Foo(); <br />     } <br />     return foo; <br />   } <br />   ... <br /> } <br /> |CODE_SMELL|MAJOR|9
Dead stores should be removed|A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value <br /> only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources. <br /> Therefore all calculated values should be used. <br /> Noncompliant Code Example <br />  <br /> i = a + b; // Noncompliant; calculation result not used before value is overwritten <br /> i = compute(); <br />  <br /> Compliant Solution <br />  <br /> i = a + b; <br /> i += compute(); <br />  <br /> Exceptions <br /> This rule ignores initializations to -1, 0, 1, null, true, false and "". <br /> See <br />  <br />    MITRE, CWE-563 - Assignment to Variable without Use ('Unused Variable')  <br />    CERT, MSC13-C. - Detect and remove unused values  <br />    CERT, MSC56-J. - Detect and remove superfluous code and values  <br /> |CODE_SMELL|MAJOR|42
Two branches in a conditional structure should not have exactly the same implementation|Having two cases in a switch statement or two branches in an if chain with the same implementation is at <br /> best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an if chain they should <br /> be combined, or for a switch, one should fall through to the other.  <br /> Noncompliant Code Example <br />  <br /> switch (i) { <br />   case 1: <br />     doFirstThing(); <br />     doSomething(); <br />     break; <br />   case 2: <br />     doSomethingDifferent(); <br />     break; <br />   case 3:  // Noncompliant; duplicates case 1's implementation <br />     doFirstThing(); <br />     doSomething(); <br />     break; <br />   default: <br />     doTheRest(); <br /> } <br />  <br /> if (a &gt;= 0 &amp;&amp; a &lt; 10) { <br />   doFirstThing(); <br />   doTheThing(); <br /> } <br /> else if (a &gt;= 10 &amp;&amp; a &lt; 20) { <br />   doTheOtherThing(); <br /> } <br /> else if (a &gt;= 20 &amp;&amp; a &lt; 50) { <br />   doFirstThing(); <br />   doTheThing();  // Noncompliant; duplicates first condition <br /> } <br /> else { <br />   doTheRest(); <br /> } <br />  <br /> Exceptions <br /> Blocks in an if chain that contain a single line of code are ignored, as are blocks in a switch statement that contain a <br /> single line of code with or without a following break. <br />  <br /> if(a == 1) { <br />   doSomething();  //no issue, usually this is done on purpose to increase the readability <br /> } else if (a == 2) { <br />   doSomethingElse(); <br /> } else { <br />   doSomething(); <br /> } <br />  <br /> But this exception does not apply to if chains without else-s, or to switch-es without default clauses when <br /> all branches have the same single line of code. In case of if chains with else-s, or of switch-es with default <br /> clauses, rule S3923 raises a bug.  <br />  <br /> if(a == 1) { <br />   doSomething();  //Noncompliant, this might have been done on purpose but probably not <br /> } else if (a == 2) { <br />   doSomething(); <br /> } <br /> |CODE_SMELL|MAJOR|5
"URL.hashCode" and "URL.equals" should be avoided|The equals and hashCode methods of java.net.URL both may trigger a name service (usually DNS) lookup to <br /> resolve the host name or IP address. Depending on the configuration, and network status, that can take a long time. URI on the other hand <br /> makes no such calls and should be used instead unless the specific URL functionality is required. <br /> In general it is better to use the URI class until access to the resource is actually needed, at which point you can just convert the <br /> URI to a URL using URI.toURL(). <br /> This rule checks for uses of URL 's in Map and Set , and for explicit calls to the equals and <br /> hashCode methods. <br /> Noncompliant Code Example <br />  <br /> public void checkUrl(URL url) { <br />   Set&lt;URL&gt; sites = new HashSet&lt;URL&gt;();  // Noncompliant <br />  <br />   URL homepage = new URL("http://sonarsource.com");  // Compliant <br />   if (homepage.equals(url)) { // Noncompliant <br />     // ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void checkUrl(URL url) { <br />   Set&lt;URI&gt; sites = new HashSet&lt;URI&gt;();  // Compliant <br />  <br />   URI homepage = new URI("http://sonarsource.com");  // Compliant <br />   URI uri = url.toURI(); <br />   if (homepage.equals(uri)) {  // Compliant <br />     // ... <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|1
Constructors should not be used to instantiate "String", "BigInteger", "BigDecimal" and primitive-wrapper classes|Constructors for String, BigInteger, BigDecimal and the objects used to wrap primitives should never be <br /> used. Doing so is less clear and uses more memory than simply using the desired value in the case of strings, and using valueOf for <br /> everything else. <br /> Noncompliant Code Example <br />  <br /> String empty = new String(); // Noncompliant; yields essentially "", so just use that. <br /> String nonempty = new String("Hello world"); // Noncompliant <br /> Double myDouble = new Double(1.1); // Noncompliant; use valueOf <br /> Integer integer = new Integer(1); // Noncompliant <br /> Boolean bool = new Boolean(true); // Noncompliant <br /> BigInteger bigInteger1 = new BigInteger("3"); // Noncompliant <br /> BigInteger bigInteger2 = new BigInteger("9223372036854775807"); // Noncompliant <br /> BigInteger bigInteger3 = new BigInteger("111222333444555666777888999"); // Compliant, greater than Long.MAX_VALUE <br />  <br /> Compliant Solution <br />  <br /> String empty = ""; <br /> String nonempty = "Hello world"; <br /> Double myDouble = Double.valueOf(1.1); <br /> Integer integer = Integer.valueOf(1); <br /> Boolean bool = Boolean.valueOf(true); <br /> BigInteger bigInteger1 = BigInteger.valueOf(3); <br /> BigInteger bigInteger2 = BigInteger.valueOf(9223372036854775807L); <br /> BigInteger bigInteger3 = new BigInteger("111222333444555666777888999"); <br />  <br /> Exceptions <br /> BigDecimal constructor with double argument is ignored as using valueOf instead might change resulting <br /> value. See S2111.|CODE_SMELL|MAJOR|129
"static" members should be accessed statically|While it is possible to access static members from a class instance, it's bad form, and considered by most to be misleading <br /> because it implies to the readers of your code that there's an instance of the member per class instance. <br /> Noncompliant Code Example <br />  <br /> public class A { <br />   public static int counter = 0; <br /> } <br />  <br /> public class B { <br />   private A first = new A(); <br />   private A second = new A(); <br />  <br />   public void runUpTheCount() { <br />     first.counter ++;  // Noncompliant <br />     second.counter ++;  // Noncompliant. A.counter is now 2, which is perhaps contrary to expectations <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class A { <br />   public static int counter = 0; <br /> } <br />  <br /> public class B { <br />   private A first = new A(); <br />   private A second = new A(); <br />  <br />   public void runUpTheCount() { <br />     A.counter ++;  // Compliant <br />     A.counter ++;  // Compliant <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|4
Parameters should be passed in the correct order|When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when <br /> the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead <br /> to unexpected results. <br /> Noncompliant Code Example <br />  <br /> public double divide(int divisor, int dividend) { <br />   return divisor/dividend; <br /> } <br />  <br /> public void doTheThing() { <br />   int divisor = 15; <br />   int dividend = 5; <br />  <br />   double result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected <br />   //... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public double divide(int divisor, int dividend) { <br />   return divisor/dividend; <br /> } <br />  <br /> public void doTheThing() { <br />   int divisor = 15; <br />   int dividend = 5; <br />  <br />   double result = divide(divisor, dividend); <br />   //... <br /> } <br /> |CODE_SMELL|MAJOR|136
Boolean expressions should not be gratuitous|If a boolean expression doesn't change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous <br /> because it does not match the programmer's intent, then it's a bug and the expression should be fixed. <br /> Noncompliant Code Example <br />  <br /> a = true; <br /> if (a) { // Noncompliant <br />   doSomething(); <br /> } <br />  <br /> if (b &amp;&amp; a) { // Noncompliant; "a" is always "true" <br />   doSomething(); <br /> } <br />  <br /> if (c &#124&#124 !a) { // Noncompliant; "!a" is always "false" <br />   doSomething(); <br /> } <br />  <br /> Compliant Solution <br />  <br /> a = true; <br /> if (foo(a)) { <br />   doSomething(); <br /> } <br />  <br /> if (b) { <br />   doSomething(); <br /> } <br />  <br /> if (c) { <br />   doSomething(); <br /> } <br />  <br /> See <br />  <br />    MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted.  <br />    MISRA C:2012, 14.3 - Controlling expressions shall not be invariant  <br />    MITRE, CWE-571 - Expression is Always True  <br />    MITRE, CWE-570 - Expression is Always False  <br />    MITRE, CWE-489 - Leftover Debug Code  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /> |CODE_SMELL|MAJOR|9
Multiline blocks should be enclosed in curly braces|Curly braces can be omitted from a one-line block, such as with an if statement or for loop, but doing so can be <br /> misleading and induce bugs.  <br /> This rule raises an issue when the whitespacing of the lines after a one line block indicates an intent to include those lines in the block, but <br /> the omission of curly braces means the lines will be unconditionally executed once. <br /> Noncompliant Code Example <br />  <br /> if (condition) <br />   firstActionInBlock(); <br />   secondAction();  // Noncompliant; executed unconditionally <br /> thirdAction(); <br />  <br /> if (condition) firstActionInBlock(); secondAction();  // Noncompliant; secondAction executed unconditionally <br />  <br /> if (condition) firstActionInBlock();  // Noncompliant <br />   secondAction();  // Executed unconditionally <br />  <br /> if (condition); secondAction();  // Noncompliant; secondAction executed unconditionally <br />  <br /> String str = null; <br /> for (int i = 0; i &lt; array.length; i++) <br />   str = array[i]; <br />   doTheThing(str);  // Noncompliant; executed only on last array element <br />  <br /> Compliant Solution <br />  <br /> if (condition) { <br />   firstActionInBlock(); <br />   secondAction(); <br /> } <br /> thirdAction(); <br />  <br /> String str = null; <br /> for (int i = 0; i &lt; array.length; i++) { <br />   str = array[i]; <br />   doTheThing(str); <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-483 - Incorrect Block Delimitation  <br />    CERT, EXP52-J. - Use braces for the body of an if, for, or while statement <br />    <br /> |CODE_SMELL|MAJOR|2
"entrySet()" should be iterated when both the key and value are needed|When only the keys from a map are needed in a loop, iterating the keySet makes sense. But when both the key and the value are needed, <br /> it's more efficient to iterate the entrySet, which will give access to both the key and value, instead. <br /> Noncompliant Code Example <br />  <br /> public void doSomethingWithMap(Map&lt;String,Object&gt; map) { <br />   for (String key : map.keySet()) {  // Noncompliant; for each key the value is retrieved <br />     Object value = map.get(key); <br />     // ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomethingWithMap(Map&lt;String,Object&gt; map) { <br />   for (Map.Entry&lt;String,Object&gt; entry : map.entrySet()) { <br />     String key = entry.getKey(); <br />     Object value = entry.getValue(); <br />     // ... <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|2
Static fields should not be updated in constructors|Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all <br /> instances of the class. <br /> Instead remove the field's static modifier, or initialize it statically. <br /> Noncompliant Code Example <br />  <br /> public class Person { <br />   static Date dateOfBirth; <br />   static int expectedFingers; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday <br />     expectedFingers = 10;  // Noncompliant <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Person { <br />   Date dateOfBirth; <br />   static int expectedFingers = 10; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday; <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|5
String function use should be optimized for single characters|An indexOf or lastIndexOf call with a single letter String can be made more performant by switching to a <br /> call with a char argument. <br /> Noncompliant Code Example <br />  <br /> String myStr = "Hello World"; <br /> // ... <br /> int pos = myStr.indexOf("W");  // Noncompliant <br /> // ... <br /> int otherPos = myStr.lastIndexOf("r"); // Noncompliant <br /> // ... <br />  <br /> Compliant Solution <br />  <br /> String myStr = "Hello World"; <br /> // ... <br /> int pos = myStr.indexOf('W'); <br /> // ... <br /> int otherPos = myStr.lastIndexOf('r'); <br /> // ... <br /> |CODE_SMELL|MAJOR|8
"writeObject" should not be the only "synchronized" code in a class|The purpose of synchronization is to ensure that only one thread executes a given block of code at a time. There's no real problem with marking <br /> writeObject synchronized, but it's highly suspicious if this serialization-related method is the only <br /> synchronized code in a class. <br /> Noncompliant Code Example <br />  <br /> public class RubberBall { <br />  <br />   private Color color; <br />   private int diameter; <br />  <br />   public RubberBall(Color color, int diameter) { <br />     // ... <br />   } <br />  <br />   public void bounce(float angle, float velocity) { <br />     // ... <br />   } <br />  <br />   private synchronized void writeObject(ObjectOutputStream stream) throws IOException { // Noncompliant <br />     // ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class RubberBall { <br />  <br />   private Color color; <br />   private int diameter; <br />  <br />    public RubberBall(Color color, int diameter) { <br />     // ... <br />   } <br />  <br />   public void bounce(float angle, float velocity) { <br />     // ... <br />   } <br />  <br />   private void writeObject(ObjectOutputStream stream) throws IOException { <br />     // ... <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|1
Ternary operators should not be nested|Just because you can do something, doesn't mean you should, and that's the case with nested ternary operations. Nesting ternary operators <br /> results in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you) <br /> scratching their heads and cursing. <br /> Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement. <br /> Noncompliant Code Example <br />  <br /> public String getTitle(Person p) { <br />   return p.gender == Person.MALE ? "Mr. " : p.isMarried() ? "Mrs. " : "Miss ";  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public String getTitle(Person p) { <br />   if (p.gender == Person.MALE) { <br />     return "Mr. "; <br />   } <br />   return p.isMarried() ? "Mrs. " : "Miss "; <br /> } <br /> |CODE_SMELL|MAJOR|12
"Map.get" and value test should be replaced with single method call|It's a common pattern to test the result of a java.util.Map.get() against null before proceeding with adding or changing <br /> the value in the map. However the java.util.Map API offers a significantly better alternative in the form of the <br /> computeIfPresent() and computeIfAbsent() methods. Using these instead leads to cleaner and more readable code. <br /> Note that this rule is automatically disabled when the project's sonar.java.source is not 8. <br /> Noncompliant Code Example <br />  <br /> V value = map.get(key); <br /> if (value == null) {  // Noncompliant <br />   value = V.createFor(key); <br />   if (value != null) { <br />     map.put(key, value); <br />   } <br /> } <br /> return value; <br />  <br /> Compliant Solution <br />  <br /> return map.computeIfAbsent(key, k -&gt; V.createFor(k)); <br /> |CODE_SMELL|MAJOR|8
"java.nio.Files#delete" should be preferred|When java.io.File#delete fails, this boolean method simply returns false with no indication of the cause. On <br /> the other hand, when java.nio.Files#delete fails, this void method returns one of a series of exception types to better <br /> indicate the cause of the failure. And since more information is generally better in a debugging situation, java.nio.Files#delete is the <br /> preferred option. <br /> Noncompliant Code Example <br />  <br /> public void cleanUp(Path path) { <br />   File file = new File(path); <br />   if (!file.delete()) {  // Noncompliant <br />     //... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void cleanUp(Path path) throws NoSuchFileException, DirectoryNotEmptyException, IOException{ <br />   Files.delete(path); <br /> } <br /> |CODE_SMELL|MAJOR|25
Methods should not have identical implementations|When two methods have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but may <br /> be confusing to maintainers. In the latter case, one implementation should invoke the other. Numerical and string literals are not taken into account. <br />  <br /> Noncompliant Code Example <br />  <br /> private final static String CODE = "bounteous"; <br />  <br /> public String calculateCode() { <br />   doTheThing(); <br />   return CODE; <br /> } <br />  <br /> public String getName() {  // Noncompliant <br />   doTheThing(); <br />   return CODE; <br /> } <br />  <br /> Compliant Solution <br />  <br /> private final static String CODE = "bounteous"; <br />  <br /> public String getCode() { <br />   doTheThing(); <br />   return CODE; <br /> } <br />  <br /> public String getName() { <br />   return getCode(); <br /> } <br />  <br /> Exceptions <br /> Methods that are not accessors (getters and setters), with fewer than 2 statements are ignored.|CODE_SMELL|MAJOR|21
Assignments should not be redundant|The transitive property says that if a == b and b == c, then a == c. In such cases, there's no point in <br /> assigning a to c or vice versa because they're already equivalent.  <br /> This rule raises an issue when an assignment is useless because the assigned-to variable already holds the value on all execution paths. <br /> Noncompliant Code Example <br />  <br /> a = b; <br /> c = a; <br /> b = c; // Noncompliant: c and b are already the same <br />  <br /> Compliant Solution <br />  <br /> a = b; <br /> c = a; <br /> |CODE_SMELL|MAJOR|1
Asserts should not be used to check the parameters of a public method|An assert is inappropriate for parameter validation because assertions can be disabled at runtime in the JVM, meaning that a bad <br /> operational setting would completely eliminate the intended checks. Further, asserts that fail throw AssertionErrors, rather <br /> than throwing some type of Exception. Throwing Errors is completely outside of the normal realm of expected <br /> catch/throw behavior in normal programs. <br /> This rule raises an issue when a public method uses one or more of its parameters with asserts. <br /> Noncompliant Code Example <br />  <br />  public void setPrice(int price) { <br />   assert price &gt;= 0 &amp;&amp; price &lt;= MAX_PRICE; <br />   // Set the price <br />  } <br />  <br /> Compliant Solution <br />  <br />  public void setPrice(int price) { <br />   if (price &lt; 0 &#124&#124 price &gt; MAX_PRICE) { <br />     throw new IllegalArgumentException("Invalid price: " + price); <br />   } <br />   // Set the price <br />  } <br />  <br /> See <br /> Programming With Assertions|CODE_SMELL|MAJOR|4
"else" statements should be clearly matched with an "if"|The dangling else problem appears when nested if/else&nbsp;statements are written without curly braces. In <br /> this case, else is associated with the nearest&nbsp;if but that is not always obvious and sometimes the indentation can also <br /> be misleading. <br /> This rules reports else statements that are difficult to understand, because they are inside nested if statements without <br /> curly braces. <br /> Adding curly braces can generally make the code clearer (RSPEC-121), and in this situation of dangling else, it really clarifies the <br /> intention of the code. <br /> Noncompliant Code Example <br />  <br />  if (a) <br />    if (b) <br />      d++; <br />  else     // Noncompliant, is the "else" associated with "if(a)" or "if (b)"? (the answer is "if(b)") <br />    e++; <br />  <br /> Compliant Solution <br />  <br />  if (a) { <br />    if (b) { <br />      d++; <br />    } <br />  } else { // Compliant, there is no doubt the "else" is associated with "if(a)" <br />    e++; <br />  } <br />  <br /> See <br />  * https://en.wikipedia.org/wiki/Dangling_else|CODE_SMELL|MAJOR|23
'List.remove()' should not be used in ascending 'for' loops|When List.remove() is called it will shrink the list. If this is done inside the ascending loop iterating through all elements it will <br /> skip the element after the removed index. <br /> Noncompliant Code Example <br />  <br /> void removeFrom(List&lt;String&gt; list) { <br />   // expected: iterate over all the elements of the list <br />   for (int i = 0; i &lt; list.size(); i++) { <br />     if (list.get(i).isEmpty()) { <br />       // actual: remaining elements are shifted, so the one immediately following will be skipped <br />       list.remove(i); // Noncompliant <br />     } <br />   } <br /> } <br />  <br /> Compliant Solution <br /> You can either adjust the loop index to account for the change in the size of the list <br />  <br /> static void removeFrom(List&lt;String&gt; list) { <br />     // expected: iterate over all the elements of the list <br />     for (int i = 0; i &lt; list.size(); i++) { <br />       if (list.get(i).isEmpty()) { <br />         // actual: remaining elements are shifted, so the one immediately following will be skipped <br />         list.remove(i); <br />         i--; <br />       } <br />     } <br />   } <br />  <br /> Or preferably it's probably better to rely on Java 8's removeIf method <br />  <br />  static void removeFrom(List&lt;String&gt; list) { <br />     list.removeIf(String::isEmpty); <br />   } <br />  <br /> &nbsp; <br /> Exceptions <br /> The descending loop doesn't have this issue, because the index will be correct when we loop in descending order <br />  <br /> void removeFrom(List&lt;String&gt; list) { <br />   for (int i = list.size() - 1; i &gt;= 0; i--) { <br />     if (list.get(i).isEmpty()) { <br />       list.remove(i); <br />     } <br />   } <br /> } <br />  <br /> &nbsp;|CODE_SMELL|MAJOR|2
Unused "private" methods should be removed|private methods that are never executed are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code <br /> decreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced. <br /> Note that this rule does not take reflection into account, which means that issues will be raised on private methods that are only <br /> accessed using the reflection API. <br /> Noncompliant Code Example <br />  <br /> public class Foo implements Serializable <br /> { <br />   private Foo(){}     //Compliant, private empty constructor intentionally used to prevent any direct instantiation of a class. <br />   public static void doSomething(){ <br />     Foo foo = new Foo(); <br />     ... <br />   } <br />   private void unusedPrivateMethod(){...} <br />   private void writeObject(ObjectOutputStream s){...}  //Compliant, relates to the java serialization mechanism <br />   private void readObject(ObjectInputStream in){...}  //Compliant, relates to the java serialization mechanism <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Foo implements Serializable <br /> { <br />   private Foo(){}     //Compliant, private empty constructor intentionally used to prevent any direct instantiation of a class. <br />   public static void doSomething(){ <br />     Foo foo = new Foo(); <br />     ... <br />   } <br />  <br />   private void writeObject(ObjectOutputStream s){...}  //Compliant, relates to the java serialization mechanism <br />  <br />   private void readObject(ObjectInputStream in){...}  //Compliant, relates to the java serialization mechanism <br /> } <br />  <br /> Exceptions <br /> This rule doesn't raise any issue on annotated methods.|CODE_SMELL|MAJOR|6
Redundant pairs of parentheses should be removed|The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But <br /> redundant pairs of parentheses could be misleading, and should be removed.  <br /> Noncompliant Code Example <br />  <br /> int x = (y / 2 + 1);   //Compliant even if the parenthesis are ignored by the compiler <br />  <br /> if (a &amp;&amp; ((x+y &gt; 0))) {  // Noncompliant <br />   //... <br /> } <br />  <br /> return ((x + 1));  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> int x = (y / 2 + 1); <br />  <br /> if (a &amp;&amp; (x+y &gt; 0)) { <br />   //... <br /> } <br />  <br /> return (x + 1); <br /> |CODE_SMELL|MAJOR|6
"@Deprecated" code should not be used|Once deprecated, classes, and interfaces, and their members should be avoided, rather than used, inherited or extended. Deprecation is a warning <br /> that the class or interface has been superseded, and will eventually be removed. The deprecation period allows you to make a smooth transition away <br /> from the aging, soon-to-be-retired technology. <br /> Noncompliant Code Example <br />  <br /> /** <br />  * @deprecated  As of release 1.3, replaced by {@link #Fee} <br />  */ <br /> @Deprecated <br /> public class Fum { ... } <br />  <br /> public class Foo { <br />   /** <br />    * @deprecated  As of release 1.7, replaced by {@link #doTheThingBetter()} <br />    */ <br />   @Deprecated <br />   public void doTheThing() { ... } <br />  <br />   public void doTheThingBetter() { ... } <br /> } <br />  <br /> public class Bar extends Foo { <br />   public void doTheThing() { ... } // Noncompliant; don't override a deprecated method or explicitly mark it as @Deprecated <br /> } <br />  <br /> public class Bar extends Fum {  // Noncompliant; Fum is deprecated <br />  <br />   public void myMethod() { <br />     Foo foo = new Foo();  // okay; the class isn't deprecated <br />     foo.doTheThing();  // Noncompliant; doTheThing method is deprecated <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-477 - Use of Obsolete Functions  <br />    CERT, MET02-J. - Do not use deprecated or obsolete classes or methods  <br /> |CODE_SMELL|MINOR|225
Empty statements should be removed|Empty statements, i.e. ;, are usually introduced by mistake, for example because: <br />  <br />    It was meant to be replaced by an actual statement, but this was forgotten.  <br />    There was a typo which lead the semicolon to be doubled, i.e. ;;.  <br />  <br /> Noncompliant Code Example <br />  <br /> void doSomething() { <br />   ;                                                       // Noncompliant - was used as a kind of TODO marker <br /> } <br />  <br /> void doSomethingElse() { <br />   System.out.println("Hello, world!");;                     // Noncompliant - double ; <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> void doSomething() {} <br />  <br /> void doSomethingElse() { <br />   System.out.println("Hello, world!"); <br />   ... <br />   for (int i = 0; i &lt; 3; i++) ; // compliant if unique statement of a loop <br />   ... <br /> } <br />  <br /> See <br />  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br />    CERT, MSC51-J. - Do not place a semicolon immediately following an if, for, <br />   or while condition  <br />    CERT, EXP15-C. - Do not place a semicolon on the same line as an if, for, <br />   or while statement  <br /> |CODE_SMELL|MINOR|58
Modifiers should be declared in the correct order|The Java Language Specification recommends listing modifiers in the following order: <br /> 1. Annotations <br /> 2. public <br /> 3. protected <br /> 4. private <br /> 5. abstract <br /> 6. static <br /> 7. final <br /> 8. transient <br /> 9. volatile <br /> 10. synchronized <br /> 11. native <br /> 12. strictfp <br /> Not following this convention has no technical impact, but will reduce the code's readability because most developers are used to the standard <br /> order. <br /> Noncompliant Code Example <br />  <br /> static public void main(String[] args) {   // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public static void main(String[] args) {   // Compliant <br /> } <br /> |CODE_SMELL|MINOR|403
"throws" declarations should not be superfluous|An exception in a throws declaration in Java is superfluous if it is: <br />  <br />    listed multiple times  <br />    a subclass of another listed exception  <br />    a RuntimeException, or one of its descendants  <br />    completely unnecessary because the declared exception type cannot actually be thrown  <br />  <br /> Noncompliant Code Example <br />  <br /> void foo() throws MyException, MyException {}  // Noncompliant; should be listed once <br /> void bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable <br /> void baz() throws RuntimeException {}  // Noncompliant; RuntimeException can always be thrown <br />  <br /> Compliant Solution <br />  <br /> void foo() throws MyException {} <br /> void bar() throws Throwable {} <br /> void baz() {} <br />  <br /> Exceptions <br /> The rule will not raise any issue for exceptions that cannot be thrown from the method body: <br />  <br />    in overriding and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw, have empty bodies, or a single return statement .  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper <br />   javadoc.  <br />  <br />  <br /> class A extends B { <br />   @Override <br />   void doSomething() throws IOException { <br />     compute(a); <br />   } <br />  <br />   public void foo() throws IOException {} <br />  <br />   protected void bar() throws IOException { <br />     throw new UnsupportedOperationException("This method should be implemented in subclasses"); <br />   } <br />  <br />   Object foobar(String s) throws IOException { <br />     return null; <br />   } <br />  <br />   /** <br />    * @throws IOException Overriding classes may throw this exception if they print values into a file <br />    */ <br />   protected void print() throws IOException { // no issue, method is overridable and the exception has proper javadoc <br />     System.out.println("foo"); <br />   } <br /> } <br /> |CODE_SMELL|MINOR|22
Method names should comply with a naming convention|Shared naming conventions allow teams to collaborate efficiently. This rule checks that all method names match a provided regular expression. <br /> Noncompliant Code Example <br /> With default provided regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public int DoSomething(){...} <br />  <br /> Compliant Solution <br />  <br /> public int doSomething(){...} <br />  <br /> Exceptions <br /> Overriding methods are excluded.  <br />  <br /> @Override <br /> public int Do_Something(){...} <br /> |CODE_SMELL|MINOR|348
Class names should comply with a naming convention|Shared coding conventions allow teams to collaborate effectively. This rule allows to check that all class names match a provided regular <br /> expression. <br /> Noncompliant Code Example <br /> With default provided regular expression ^[A-Z][a-zA-Z0-9]*$: <br />  <br /> class my_class {...} <br />  <br /> Compliant Solution <br />  <br /> class MyClass {...} <br /> |CODE_SMELL|MINOR|7
Field names should comply with a naming convention|Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field <br /> names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> class MyClass { <br />    private int my_field; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />    private int myField; <br /> } <br /> |CODE_SMELL|MINOR|28
Local variable and method parameter names should comply with a naming convention|Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when a local variable or function parameter name does <br /> not match the provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public void doSomething(int my_param) { <br />   int LOCAL; <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(int myParam) { <br />   int local; <br />   ... <br /> } <br />  <br /> Exceptions <br /> Loop counters are ignored by this rule. <br />  <br /> for (int i_1 = 0; i_1 &lt; limit; i_1++) {  // Compliant <br />   // ... <br /> } <br />  <br /> as well as one-character catch variables:  <br />  <br /> try { <br /> //... <br /> } catch (Exception e) { // Compliant <br /> } <br /> |CODE_SMELL|MINOR|161
URIs should not be hardcoded|Hard coding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may <br /> not exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems <br /> usually differ from the development environment, ...etc. For all those reasons, a URI should never be hard coded. Instead, it should be replaced by <br /> customizable parameter. <br /> Further even if the elements of a URI are obtained dynamically, portability can still be limited if the path-delimiters are hard-coded. <br /> This rule raises an issue when URI's or path delimiters are hard coded. <br /> Noncompliant Code Example <br />  <br /> public class Foo { <br />   public Collection&lt;User&gt; listUsers() { <br />     File userList = new File("/home/mylogin/Dev/users.txt"); // Non-Compliant <br />     Collection&lt;User&gt; users = parse(userList); <br />     return users; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Foo { <br />   // Configuration is a class that returns customizable properties: it can be mocked to be injected during tests. <br />   private Configuration config; <br />   public Foo(Configuration myConfig) { <br />     this.config = myConfig; <br />   } <br />   public Collection&lt;User&gt; listUsers() { <br />     // Find here the way to get the correct folder, in this case using the Configuration object <br />     String listingFolder = config.getProperty("myApplication.listingFolder"); <br />     // and use this parameter instead of the hard coded path <br />     File userList = new File(listingFolder, "users.txt"); // Compliant <br />     Collection&lt;User&gt; users = parse(userList); <br />     return users; <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, MSC03-J. - Never hard code sensitive information  <br /> |CODE_SMELL|MINOR|5
Boolean literals should not be redundant|Redundant Boolean literals should be removed from expressions to improve readability. <br /> Noncompliant Code Example <br />  <br /> if (booleanMethod() == true) { /* ... */ } <br /> if (booleanMethod() == false) { /* ... */ } <br /> if (booleanMethod() &#124&#124 false) { /* ... */ } <br /> doSomething(!false); <br /> doSomething(booleanMethod() == true); <br />  <br /> booleanVariable = booleanMethod() ? true : false; <br /> booleanVariable = booleanMethod() ? true : exp; <br /> booleanVariable = booleanMethod() ? false : exp; <br /> booleanVariable = booleanMethod() ? exp : true; <br /> booleanVariable = booleanMethod() ? exp : false; <br />  <br /> Compliant Solution <br />  <br /> if (booleanMethod()) { /* ... */ } <br /> if (!booleanMethod()) { /* ... */ } <br /> if (booleanMethod()) { /* ... */ } <br /> doSomething(true); <br /> doSomething(booleanMethod()); <br />  <br /> booleanVariable = booleanMethod(); <br /> booleanVariable = booleanMethod() &#124&#124 exp; <br /> booleanVariable = !booleanMethod() &amp;&amp; exp; <br /> booleanVariable = !booleanMethod() &#124&#124 exp; <br /> booleanVariable = booleanMethod() &amp;&amp; exp; <br /> |CODE_SMELL|MINOR|5
Return of boolean expressions should not be wrapped into an "if-then-else" statement|Return of boolean literal statements wrapped into if-then-else ones should be simplified. <br /> Similarly, method invocations wrapped into if-then-else differing only from boolean literals should be simplified into a single <br /> invocation. <br /> Noncompliant Code Example <br />  <br /> boolean foo(Object param) { <br />   if (expression) { // Noncompliant <br />     bar(param, true, "qix"); <br />   } else { <br />     bar(param, false, "qix"); <br />   } <br />  <br />   if (expression) {  // Noncompliant <br />     return true; <br />   } else { <br />     return false; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> boolean foo(Object param) { <br />   bar(param, expression, "qix"); <br />  <br />   return expression; <br /> } <br /> |CODE_SMELL|MINOR|176
Collection.isEmpty() should be used to test for emptiness|Using Collection.size() to test for emptiness works, but using Collection.isEmpty() makes the code more readable and can <br /> be more performant. The time complexity of any isEmpty() method implementation should be O(1) whereas some implementations <br /> of size() can be O(n). <br /> Noncompliant Code Example <br />  <br /> if (myCollection.size() == 0) {  // Noncompliant <br />   /* ... */ <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (myCollection.isEmpty()) { <br />   /* ... */ <br /> } <br /> |CODE_SMELL|MINOR|5
Exception classes should be immutable|Exceptions are meant to represent the application's state at the point at which an error occurred. <br /> Making all fields in an Exception class final ensures that this state: <br />  <br />    Will be fully defined at the same time the Exception is instantiated.  <br />    Won't be updated or corrupted by a questionable error handler.  <br />  <br /> This will enable developers to quickly understand what went wrong. <br /> Noncompliant Code Example <br />  <br /> public class MyException extends Exception { <br />  <br />   private int status;                               // Noncompliant <br />  <br />   public MyException(String message) { <br />     super(message); <br />   } <br />  <br />   public int getStatus() { <br />     return status; <br />   } <br />  <br />   public void setStatus(int status) { <br />     this.status = status; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyException extends Exception { <br />  <br />   private final int status; <br />  <br />   public MyException(String message, int status) { <br />     super(message); <br />     this.status = status; <br />   } <br />  <br />   public int getStatus() { <br />     return status; <br />   } <br />  <br /> } <br /> |CODE_SMELL|MINOR|4
Overriding methods should do more than simply call the same method in the super class|Overriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time <br /> this is justified is in final overriding methods, where the effect is to lock in the parent class behavior. This rule ignores such <br /> overrides of equals, hashCode and toString. <br /> Noncompliant Code Example <br />  <br /> public void doSomething() { <br />   super.doSomething(); <br /> } <br />  <br /> @Override <br /> public boolean isLegal(Action action) { <br />   return super.isLegal(action); <br /> } <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public boolean isLegal(Action action) {         // Compliant - not simply forwarding the call <br />   return super.isLegal(new Action(/* ... */)); <br /> } <br />  <br /> @Id <br /> @Override <br /> public int getId() {                            // Compliant - there is annotation different from @Override <br />   return super.getId(); <br /> } <br /> |CODE_SMELL|MINOR|10
Array designators "[]" should be on the type, not the variable|Array designators should always be located on the type for better code readability. Otherwise, developers must look both at the type and the <br /> variable name to know whether or not a variable is an array. <br /> Noncompliant Code Example <br />  <br /> int matrix[][];   // Noncompliant <br /> int[] matrix[];   // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> int[][] matrix;   // Compliant <br /> |CODE_SMELL|MINOR|20
Nested code blocks should not be used|Nested code blocks can be used to create a new scope and restrict the visibility of the variables defined inside it. Using this feature in a method <br /> typically indicates that the method has too many responsibilities, and should be refactored into smaller methods. <br /> Noncompliant Code Example <br />  <br /> public void evaluate(int operator) { <br />   switch (operator) { <br />     /* ... */ <br />     case ADD: {                                // Noncompliant - nested code block '{' ... '}' <br />         int a = stack.pop(); <br />         int b = stack.pop(); <br />         int result = a + b; <br />         stack.push(result); <br />         break; <br />       } <br />     /* ... */ <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void evaluate(int operator) { <br />   switch (operator) { <br />     /* ... */ <br />     case ADD:                                  // Compliant <br />       evaluateAdd(); <br />       break; <br />     /* ... */ <br />   } <br /> } <br />  <br /> private void evaluateAdd() { <br />   int a = stack.pop(); <br />   int b = stack.pop(); <br />   int result = a + b; <br />   stack.push(result); <br /> } <br /> |CODE_SMELL|MINOR|121
"equals(Object obj)" should be overridden along with the "compareTo(T obj)" method|According to the Java Comparable.compareTo(T o) documentation: <br />  <br />   It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). <br />   Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. <br />   The recommended language is "Note: this class has a natural ordering that is inconsistent with equals."  <br />  <br /> If this rule is violated, weird and unpredictable failures can occur. <br /> For example, in Java 5 the PriorityQueue.remove() method relied on compareTo(), but since Java 6 it has relied on <br /> equals(). <br /> Noncompliant Code Example <br />  <br /> public class Foo implements Comparable&lt;Foo&gt; { <br />   @Override <br />   public int compareTo(Foo foo) { /* ... */ }      // Noncompliant as the equals(Object obj) method is not overridden <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Foo implements Comparable&lt;Foo&gt; { <br />   @Override <br />   public int compareTo(Foo foo) { /* ... */ }      // Compliant <br />  <br />   @Override <br />   public boolean equals(Object obj) { /* ... */ } <br /> } <br /> |CODE_SMELL|MINOR|1
A "while" loop should be used instead of a "for" loop|When only the condition expression is defined in a for loop, and the initialization and increment expressions are missing, a <br /> while loop should be used instead to increase readability.  <br /> Noncompliant Code Example <br />  <br /> for (;condition;) { /*...*/ } <br />  <br /> Compliant Solution <br />  <br /> while (condition) { /*...*/ } <br /> |CODE_SMELL|MINOR|1
"switch" statements should have at least 3 "case" clauses|switch statements are useful when there are many different cases depending on the value of the same expression. <br /> For just one or two cases however, the code will be more readable with if statements. <br /> Noncompliant Code Example <br />  <br /> switch (variable) { <br />   case 0: <br />     doSomething(); <br />     break; <br />   default: <br />     doSomethingElse(); <br />     break; <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (variable == 0) { <br />   doSomething(); <br /> } else { <br />   doSomethingElse(); <br /> } <br /> |CODE_SMELL|MINOR|58
Declarations should use Java collection interfaces such as "List" rather than specific implementation classes such as "LinkedList"|The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details. <br /> Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose <br /> type is a Java Collection interface. <br /> This rule raises an issue when an implementation class: <br />  <br />    is returned from a public method.  <br />    is accepted as an argument to a public method.  <br />    is exposed as a public member.  <br />  <br /> Noncompliant Code Example <br />  <br /> public class Employees { <br />   private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();  // Noncompliant - "employees" should have type "Set" rather than "HashSet" <br />  <br />   public HashSet&lt;Employee&gt; getEmployees() {                       // Noncompliant <br />     return employees; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Employees { <br />   private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();      // Compliant <br />  <br />   public Set&lt;Employee&gt; getEmployees() {                           // Compliant <br />     return employees; <br />   } <br /> } <br /> |CODE_SMELL|MINOR|21
Loops should not contain more than a single "break" or "continue" statement|Restricting the number of break and continue statements in a loop is done in the interest of good structured programming. <br />  <br /> One break and continue statement is acceptable in a loop, since it facilitates optimal coding. If there is more than one, <br /> the code should be refactored to increase readability. <br /> Noncompliant Code Example <br />  <br /> for (int i = 1; i &lt;= 10; i++) {     // Noncompliant - 2 continue - one might be tempted to add some logic in between <br />   if (i % 2 == 0) { <br />     continue; <br />   } <br />  <br />   if (i % 3 == 0) { <br />     continue; <br />   } <br />  <br />   System.out.println("i = " + i); <br /> } <br /> |CODE_SMELL|MINOR|35
Private fields only used as local variables in methods should become local variables|When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class <br /> information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding. <br /> Noncompliant Code Example <br />  <br /> public class Foo { <br />   private int a; <br />   private int b; <br />  <br />   public void doSomething(int y) { <br />     a = y + 5; <br />     ... <br />     if(a == 0) { <br />       ... <br />     } <br />     ... <br />   } <br />  <br />   public void doSomethingElse(int y) { <br />     b = y + 3; <br />     ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Foo { <br />  <br />   public void doSomething(int y) { <br />     int a = y + 5; <br />     ... <br />     if(a == 0) { <br />       ... <br />     } <br />   } <br />  <br />   public void doSomethingElse(int y) { <br />     int b = y + 3; <br />     ... <br />   } <br /> } <br />  <br /> Exceptions <br /> This rule doesn't raise any issue on annotated field.|CODE_SMELL|MINOR|10
Unused local variables should be removed|If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will <br /> not wonder what the variable is used for. <br /> Noncompliant Code Example <br />  <br /> public int numberOfMinutes(int hours) { <br />   int seconds = 0;   // seconds is never used <br />   return hours * 60; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public int numberOfMinutes(int hours) { <br />   return hours * 60; <br /> } <br /> |CODE_SMELL|MINOR|27
Local variables should not be declared and then immediately returned or thrown|Declaring a variable only to immediately return or throw it is a bad practice. <br /> Some developers argue that the practice improves code readability, because it enables them to explicitly name what is being returned. However, this <br /> variable is an internal implementation detail that is not exposed to the callers of the method. The method name should be sufficient for callers to <br /> know exactly what will be returned. <br /> Noncompliant Code Example <br />  <br /> public long computeDurationInMilliseconds() { <br />   long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; <br />   return duration; <br /> } <br />  <br /> public void doSomething() { <br />   RuntimeException myException = new RuntimeException(); <br />   throw myException; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public long computeDurationInMilliseconds() { <br />   return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; <br /> } <br />  <br /> public void doSomething() { <br />   throw new RuntimeException(); <br /> } <br /> |CODE_SMELL|MINOR|34
Abstract classes without fields should be converted to interfaces|With Java 8's "default method" feature, any abstract class without direct or inherited field should be converted into an interface. However, this <br /> change may not be appropriate in libraries or other applications where the class is intended to be used as an API. <br /> Note that this rule is automatically disabled when the project's sonar.java.source is lower than 8. <br /> Noncompliant Code Example <br />  <br /> public abstract class Car { <br />   public abstract void start(Environment c); <br />  <br />   public void stop(Environment c) { <br />     c.freeze(this); <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public interface Car { <br />   public void start(Environment c); <br />  <br />   public default void stop(Environment c) { <br />     c.freeze(this); <br />   } <br /> } <br /> |CODE_SMELL|MINOR|2
Strings should not be concatenated using '+' in a loop|Strings are immutable objects, so concatenation doesn't simply add the new String to the end of the existing string. Instead, in each loop <br /> iteration, the first String is converted to an intermediate object type, the second string is appended, and then the intermediate object is converted <br /> back to a String. Further, performance of these intermediate operations degrades as the String gets longer. Therefore, the use of StringBuilder is <br /> preferred. <br /> Noncompliant Code Example <br />  <br /> String str = ""; <br /> for (int i = 0; i &lt; arrayOfStrings.length ; ++i) { <br />   str = str + arrayOfStrings[i]; <br /> } <br />  <br /> Compliant Solution <br />  <br /> StringBuilder bld = new StringBuilder(); <br />   for (int i = 0; i &lt; arrayOfStrings.length; ++i) { <br />     bld.append(arrayOfStrings[i]); <br />   } <br />   String str = bld.toString(); <br /> |CODE_SMELL|MINOR|13
Multiple variables should not be declared on the same line|Declaring multiple variables on one line is difficult to read. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />  <br />   private int a, b; <br />  <br />   public void method(){ <br />     int c; int d; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />  <br />   private int a; <br />   private int b; <br />  <br />   public void method(){ <br />     int c; <br />     int d; <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, DCL52-J. - Do not declare more than one variable per declaration <br />    <br />    CERT, DCL04-C. - Do not declare more than one variable per declaration  <br /> |CODE_SMELL|MINOR|141
"toString()" should never be called on a String object|Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. This redundant <br /> construction may be optimized by the compiler, but will be confusing in the meantime. <br /> Noncompliant Code Example <br />  <br /> String message = "hello world"; <br /> System.out.println(message.toString()); // Noncompliant; <br />  <br /> Compliant Solution <br />  <br /> String message = "hello world"; <br /> System.out.println(message); <br /> |CODE_SMELL|MINOR|1
Redundant casts should not be used|Unnecessary casting expressions make the code harder to read and understand. <br /> Noncompliant Code Example <br />  <br /> public void example() { <br />   for (Foo obj : (List&lt;Foo&gt;) getFoos()) {  // Noncompliant; cast unnecessary because List&lt;Foo&gt; is what's returned <br />     //... <br />   } <br /> } <br />  <br /> public List&lt;Foo&gt; getFoos() { <br />   return this.foos; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void example() { <br />   for (Foo obj : getFoos()) { <br />     //... <br />   } <br /> } <br />  <br /> public List&lt;Foo&gt; getFoos() { <br />   return this.foos; <br /> } <br />  <br /> Exceptions <br /> Casting may be required to distinguish the method to call in the case of overloading: <br />  <br /> class A {} <br /> class B extends A{} <br /> class C { <br />   void fun(A a){} <br />   void fun(B b){} <br />  <br />   void foo() { <br />     B b = new B(); <br />     fun(b); <br />     fun((A) b); //call the first method so cast is not redundant. <br />   } <br />  <br /> } <br /> |CODE_SMELL|MINOR|27
Boolean checks should not be inverted|It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead. <br /> Noncompliant Code Example <br />  <br /> if ( !(a == 2)) { ...}  // Noncompliant <br /> boolean b = !(i &lt; 10);  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> if (a != 2) { ...} <br /> boolean b = (i &gt;= 10); <br /> |CODE_SMELL|MINOR|3
Fields in non-serializable classes should not be "transient"|transient is used to mark fields in a Serializable class which will not be written out to file (or stream). In a class <br /> that does not implement Serializable, this modifier is simply wasted keystrokes, and should be removed. <br /> Noncompliant Code Example <br />  <br /> class Vegetable {  // does not implement Serializable <br />   private transient Season ripe;  // Noncompliant <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> class Vegetable { <br />   private Season ripe; <br />   // ... <br /> } <br /> |CODE_SMELL|MINOR|6
Classes should not be empty|There is no good excuse for an empty class. If it's being used simply as a common extension point, it should be replaced with an <br /> interface. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be <br /> eliminated. <br /> Noncompliant Code Example <br />  <br /> public class Nothing {  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public interface Nothing { <br /> } <br />  <br /> Exceptions <br /> Empty classes can be used as marker types (for Spring for instance), therefore empty classes that are annotated will be ignored. <br />  <br /> @Configuration <br /> @EnableWebMvc <br /> public final class ApplicationConfiguration { <br />  <br /> } <br /> |CODE_SMELL|MINOR|1
Parsing should be used to convert "Strings" to primitives|Rather than creating a boxed primitive from a String to extract the primitive value, use the relevant parse method <br /> instead. It will be clearer and more efficient. <br /> Noncompliant Code Example <br />  <br /> String myNum = "12.2"; <br />  <br /> float f = (new Float(myNum)).floatValue();  // Noncompliant; creates &amp; discards a Float <br />  <br /> Compliant Solution <br />  <br /> String myNum = "12.2"; <br />  <br /> float f = Float.parseFloat(myNum); <br /> |CODE_SMELL|MINOR|4
Catches should be combined|Since Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiple catch blocks have the same code, they <br /> should be combined for better readability. <br /> Note that this rule is automatically disabled when the project's sonar.java.source is lower than 7. <br /> Noncompliant Code Example <br />  <br /> catch (IOException e) { <br />   doCleanup(); <br />   logger.log(e); <br /> } <br /> catch (SQLException e) {  // Noncompliant <br />   doCleanup(); <br />   logger.log(e); <br /> } <br /> catch (TimeoutException e) {  // Compliant; block contents are different <br />   doCleanup(); <br />   throw e; <br /> } <br />  <br /> Compliant Solution <br />  <br /> catch (IOException&#124SQLException e) { <br />   doCleanup(); <br />   logger.log(e); <br /> } <br /> catch (TimeoutException e) { <br />   doCleanup(); <br />   throw e; <br /> } <br /> |CODE_SMELL|MINOR|14
Subclasses that add fields should override "equals"|Extend a class that overrides equals and add fields without overriding equals in the subclass, and you run the risk of <br /> non-equivalent instances of your subclass being seen as equal, because only the superclass fields will be considered in the equality test. <br /> This rule looks for classes that do all of the following: <br />  <br />    extend classes that override equals.  <br />    do not themselves override equals.  <br />    add fields.  <br />  <br /> Noncompliant Code Example <br />  <br /> public class Fruit { <br />   private Season ripe; <br />  <br />   public boolean equals(Object obj) { <br />     if (obj == this) { <br />       return true; <br />     } <br />     if (this.class != obj.class) { <br />       return false; <br />     } <br />     Fruit fobj = (Fruit) obj; <br />     if (ripe.equals(fobj.getRipe()) { <br />       return true; <br />     } <br />     return false; <br />   } <br /> } <br />  <br /> public class Raspberry extends Fruit {  // Noncompliant; instances will use Fruit's equals method <br />   private Color ripeColor; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Fruit { <br />   private Season ripe; <br />  <br />   public boolean equals(Object obj) { <br />     if (obj == this) { <br />       return true; <br />     } <br />     if (this.class != obj.class) { <br />       return false; <br />     } <br />     Fruit fobj = (Fruit) obj; <br />     if (ripe.equals(fobj.getRipe()) { <br />       return true; <br />     } <br />     return false; <br />   } <br /> } <br />  <br /> public class Raspberry extends Fruit { <br />   private Color ripeColor; <br />  <br />   public boolean equals(Object obj) { <br />     if (! super.equals(obj)) { <br />       return false; <br />     } <br />     Raspberry fobj = (Raspberry) obj; <br />     if (ripeColor.equals(fobj.getRipeColor()) {  // added fields are tested <br />       return true; <br />     } <br />     return false; <br />   } <br /> } <br /> |CODE_SMELL|MINOR|1
The diamond operator ("<>") should be used|Java 7 introduced the diamond operator (&lt;&gt;) to reduce the verbosity of generics code. For instance, instead of having to declare <br /> a List's type in both its declaration and its constructor, you can now simplify the constructor declaration with &lt;&gt;, <br /> and the compiler will infer the type. <br /> Note that this rule is automatically disabled when the project's sonar.java.source is lower than 7. <br /> Noncompliant Code Example <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;String&gt;();  // Noncompliant <br /> Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;String,List&lt;Integer&gt;&gt;();  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;&gt;(); <br /> Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); <br /> |CODE_SMELL|MINOR|382
Nested "enum"s should not be declared static|According to the docs: <br />  <br />   Nested enum types are implicitly <br />   static. <br />  <br /> So there's no need to declare them static explicitly. <br /> Noncompliant Code Example <br />  <br /> public class Flower { <br />   static enum Color { // Noncompliant; static is redundant here <br />     RED, YELLOW, BLUE, ORANGE <br />   } <br />  <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Flower { <br />   enum Color { // Compliant <br />     RED, YELLOW, BLUE, ORANGE <br />   } <br />  <br />   // ... <br /> } <br /> |CODE_SMELL|MINOR|3
Static non-final field names should comply with a naming convention|Shared naming conventions allow teams to collaborate efficiently. This rule checks that static non-final field names match a provided regular <br /> expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public final class MyClass { <br />    private static String foo_bar; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />    private static String fooBar; <br /> } <br /> |CODE_SMELL|MINOR|46
"private" methods called only by inner classes should be moved to those classes|When a private method is only invoked by an inner class, there's no reason not to move it into that class. It will still have the same <br /> access to the outer class' members, but the outer class will be clearer and less cluttered. <br /> Noncompliant Code Example <br />  <br /> public class Outie { <br />   private int i=0; <br />  <br />   private void increment() {  // Noncompliant <br />     i++; <br />   } <br />  <br />   public class Innie { <br />     public void doTheThing() { <br />       Outie.this.increment(); <br />     } <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Outie { <br />   private int i=0; <br />  <br />   public class Innie { <br />     public void doTheThing() { <br />       increment(); <br />     } <br />  <br />     private void increment() { <br />       Outie.this.i++; <br />     } <br />   } <br /> } <br /> |CODE_SMELL|MINOR|18
Methods should not return constants|There's no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a <br /> method call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead.  <br /> This rule raises an issue if on methods that contain only one statement: the return of a constant value.  <br /> Noncompliant Code Example <br />  <br /> int getBestNumber() { <br />   return 12;  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> static int bestNumber = 12; <br />  <br /> Exceptions <br /> Methods with annotations, such as @Override and Spring's @RequestMapping, are ignored.|CODE_SMELL|MINOR|6
Jump statements should not be redundant|Jump statements such as return and continue let you change the default flow of program execution, but jump statements <br /> that direct the control flow to the original direction are just a waste of keystrokes. <br /> Noncompliant Code Example <br />  <br /> public void foo() { <br />   while (condition1) { <br />     if (condition2) { <br />       continue; // Noncompliant <br />     } else { <br />       doTheThing(); <br />     } <br />   } <br />   return; // Noncompliant; this is a void method <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void foo() { <br />   while (condition1) { <br />     if (!condition2) { <br />       doTheThing(); <br />     } <br />   } <br /> } <br /> |CODE_SMELL|MINOR|10
Arrays should not be created for varargs parameters|There's no point in creating an array solely for the purpose of passing it as a varargs (...) argument; varargs is an array. <br /> Simply pass the elements directly. They will be consolidated into an array automatically. Incidentally passing an array where Object ... <br /> is expected makes the intent ambiguous: Is the array supposed to be one object or a collection of objects? <br /> Noncompliant Code Example <br />  <br /> public void callTheThing() { <br />   //... <br />   doTheThing(new String[] { "s1", "s2"});  // Noncompliant: unnecessary <br />   doTheThing(new String[12]);  // Compliant <br />   doTheOtherThing(new String[8]);  // Noncompliant: ambiguous <br />   // ... <br /> } <br />  <br /> public void doTheThing (String ... args) { <br />   // ... <br /> } <br />  <br /> public void doTheOtherThing(Object ... args) { <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void callTheThing() { <br />   //... <br />   doTheThing("s1", "s2"); <br />   doTheThing(new String[12]); <br />   doTheOtherThing((Object[]) new String[8]); <br />    // ... <br /> } <br />  <br /> public void doTheThing (String ... args) { <br />   // ... <br /> } <br />  <br /> public void doTheOtherThing(Object ... args) { <br />   // ... <br /> } <br /> |CODE_SMELL|MINOR|5
Null checks should not be used with "instanceof"|There's no need to null test in conjunction with an instanceof test. null is not an instanceof anything, so <br /> a null check is redundant. <br /> Noncompliant Code Example <br />  <br /> if (x != null &amp;&amp; x instanceof MyClass) { ... }  // Noncompliant <br />  <br /> if (x == null &#124&#124 ! x instanceof MyClass) { ... } // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> if (x instanceof MyClass) { ... } <br />  <br /> if (! x instanceof MyClass) { ... } <br /> |CODE_SMELL|MINOR|5
"StandardCharsets" constants should be preferred|JDK7 introduced the class java.nio.charset.StandardCharsets. It provides constants for all charsets that are guaranteed to be <br /> available on every implementation of the Java platform. <br />  <br />    ISO_8859_1  <br />    US_ASCII  <br />    UTF_16  <br />    UTF_16BE  <br />    UTF_16LE  <br />    UTF_8  <br />  <br /> These constants should be preferred to: <br /> - the use of a String such as "UTF-8" which has the drawback of requiring the catch/throw of an <br /> UnsupportedEncodingException that will never actually happen <br /> - the use of Guavas Charsets class, which has been obsolete since JDK7 <br /> Noncompliant Code Example <br />  <br /> try { <br />   byte[] bytes = string.getBytes("UTF-8"); // Noncompliant; use a String instead of StandardCharsets.UTF_8 <br /> } catch (UnsupportedEncodingException e) { <br />   throw new AssertionError(e); <br /> } <br /> // ... <br /> byte[] bytes = string.getBytes(Charsets.UTF_8); // Noncompliant; Guava way obsolete since JDK7 <br />  <br /> Compliant Solution <br />  <br /> byte[] bytes = string.getBytes(StandardCharsets.UTF_8) <br /> |CODE_SMELL|MINOR|6
An iteration on a Collection should be performed on the type handled by the Collection|This rule raises an issue when an iteration over the items of a Collection is performed on a super-type of the type handled by the <br /> Collection. <br /> Relying on Object or any classes between Object and the real class handled by the Collection is not <br /> recommended. While it's accepted by the language, this practice reduces readability of the code and forces to down-cast the item of the <br /> Collection to be able to call a method on it while simply using the correct type in the iteration makes things more clear and simple. <br /> Noncompliant Code Example <br />  <br /> public Collection&lt;Person&gt; getPersons() { ... } <br />  <br /> for (Object item : getPersons()) { // Noncompliant <br />   Person person = (Person) item; // Noncompliant; it's required to down-cast to the to correct type to use "item" <br />   person.getAdress(); <br /> } <br />  <br /> Compliant Solution <br />  <br /> for (Person person : getPersons()) { // Compliant <br />   person.getAddress() ; <br /> } <br /> |CODE_SMELL|MINOR|1
Boxed "Boolean" should be avoided in boolean expressions|When boxed type java.lang.Boolean is used as an expression it will throw NullPointerException if the value is <br /> null as defined in Java Language Specification 5.1.8 <br /> Unboxing Conversion. <br /> It is safer to avoid such conversion altogether and handle the null value explicitly. <br /> Noncompliant Code Example <br />  <br /> Boolean b = getBoolean(); <br /> if (b) {  // Noncompliant, it will throw NPE when b == null <br />   foo(); <br /> } else { <br />   bar(); <br /> } <br />  <br /> Compliant Solution <br />  <br /> Boolean b = getBoolean(); <br /> if (Boolean.TRUE.equals(b)) { <br />   foo(); <br /> } else { <br />   bar();  // will be invoked for both b == false and b == null <br /> } <br />  <br /> See <br />  * Java Language Specification 5.1.8 Unboxing Conversion|CODE_SMELL|MINOR|9
Unnecessary imports should be removed|The imports part of a file should be handled by the Integrated Development Environment (IDE), not manually by the developer.  <br /> Unused and useless imports should not occur if that is the case.  <br /> Leaving them in reduces the code's readability, since their presence can be confusing. <br /> Noncompliant Code Example <br />  <br /> package my.company; <br />  <br /> import java.lang.String;        // Noncompliant; java.lang classes are always implicitly imported <br /> import my.company.SomeClass;    // Noncompliant; same-package files are always implicitly imported <br /> import java.io.File;            // Noncompliant; File is not used <br />  <br /> import my.company2.SomeType; <br /> import my.company2.SomeType;    // Noncompliant; 'SomeType' is already imported <br />  <br /> class ExampleClass { <br />  <br />   public String someString; <br />   public SomeType something; <br />  <br /> } <br />  <br /> Exceptions <br /> Imports for types mentioned in comments, such as Javadocs, are ignored.|CODE_SMELL|MINOR|15
Using pseudorandom number generators (PRNGs) is security-sensitive|Using pseudorandom number generators (PRNGs) is security-sensitive. For example, it has led in the past to the following vulnerabilities: <br />  <br />    CVE-2013-6386  <br />    CVE-2006-3419  <br />    CVE-2008-4102  <br />  <br /> When software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that <br /> will be generated, and use this guess to impersonate another user or access sensitive information. <br /> As the java.util.Random class relies on a pseudorandom number generator, this class and relating java.lang.Math.random() <br /> method should not be used for security-critical applications or for protecting sensitive data. In such context, the <br /> java.security.SecureRandom class which relies on a cryptographically strong random number generator (RNG) should be used in place. <br /> Ask Yourself Whether <br />  <br />    the code using the generated value requires it to be unpredictable. It is the case for all encryption mechanisms or when a secret value, such <br />   as a password, is hashed.  <br />    the function you use generates a value which can be predicted (pseudo-random).  <br />    the generated value is used multiple times.  <br />    an attacker can access the generated value.  <br />  <br /> You are at risk if you answered yes to the first question and any of the following ones. <br /> Recommended Secure Coding Practices <br />  <br />    Use a cryptographically strong random number generator (RNG) like "java.security.SecureRandom" in place of this PRNG.  <br />    Use the generated random values only once.  <br />    You should not expose the generated random value. If you have to store it, make sure that the database or file is secure.  <br />  <br /> Sensitive Code Example <br />  <br /> Random random = new Random(); // Questionable use of Random <br /> byte bytes[] = new byte[20]; <br /> random.nextBytes(bytes); // Check if bytes is used for hashing, encryption, etc... <br />  <br /> Compliant Solution <br />  <br /> SecureRandom random = new SecureRandom(); // Compliant for security-sensitive use cases <br /> byte bytes[] = new byte[20]; <br /> random.nextBytes(bytes); <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    MITRE, CWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator <br />   (PRNG)  <br />    MITRE, CWE-330 - Use of Insufficiently Random Values  <br />    MITRE, CWE-326 - Inadequate Encryption Strength  <br />    CERT, MSC02-J. - Generate strong random numbers  <br />    CERT, MSC30-C. - Do not use the rand() function for generating pseudorandom <br />   numbers  <br />    CERT, MSC50-CPP. - Do not use std::rand() for generating pseudorandom <br />   numbers  <br />    Derived from FindSecBugs rule Predictable Pseudo Random Number <br />   Generator  <br /> |SECURITY_HOTSPOT|CRITICAL|2
Changing or bypassing accessibility is security-sensitive|Changing or bypassing accessibility is security-sensitive. For example, it has led in the past to the following vulnerability: <br />  <br />    CVE-2012-4681  <br />  <br /> private methods were made private for a reason, and the same is true of every other visibility level. Altering or <br /> bypassing the accessibility of classes, methods, or fields violates the encapsulation principle and could introduce security holes. <br /> This rule raises an issue when reflection is used to change the visibility of a class, method or field, and when it is used to directly update a <br /> field value. <br /> Ask Yourself Whether <br />  <br />    there is a good reason to override the existing accessibility level of the method/field. This is very rarely the case. Accessing hidden fields <br />   and methods will make your code unstable as they are not part of the public API and may change in future versions.  <br />    this method is called by untrusted code. *  <br />    it is possible to modify or bypass the accessibility of sensitive methods or fields using this code. *  <br />    untrusted code can access the java reflection API. *  <br />  <br /> * You are at risk if you answered yes to those questions. <br /> Recommended Secure Coding Practices <br /> Don't change or bypass the accessibility of any method or field if possible. <br /> If untrusted code can execute this method, make sure that it cannot decide which method or field's accessibility can be modified or bypassed. <br /> Untrusted code should never have direct access to the java Reflection API. If this method can do it, make sure that it is an exception. Use <br /> ClassLoaders and SecurityManagers in order to sandbox any untrusted code and forbid access to the Reflection API. <br /> Sensitive Code Example <br />  <br /> public void makeItPublic(String methodName) throws NoSuchMethodException { <br />  <br />   this.getClass().getMethod(methodName).setAccessible(true); // Questionable <br /> } <br />  <br /> public void setItAnyway(String fieldName, int value) { <br />   this.getClass().getDeclaredField(fieldName).setInt(this, value); // Questionable; bypasses controls in setter <br /> } <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    CERT, SEC05-J. - Do not use reflection to increase accessibility of <br />   classes, methods, or fields  <br /> |SECURITY_HOTSPOT|CRITICAL|4
Deserializing objects from an untrusted source is security-sensitive|Deserializing objects is security-sensitive. For example, it has led in the past to the following vulnerabilities: <br />  <br />    CVE-2018-10654: Hazelcast Library: Java deserialization <br />   vulnerability  <br />    CVE-2018-1000058: Jenkins Pipeline: arbitrary code execution <br />   vulnerability  <br />  <br /> Object deserialization from an untrusted source can lead to unexpected code execution. ObjectInputStream doesn't provide a way to <br /> apply rules on its InputStream argument. Knowing that all serializable classes in the scope of the classloader will be deserialized, <br /> there is a possibility that malicious code could be executed during the deserialization phase even if, in the end, a ClassCastException <br /> will be raised. <br /> Deserialization takes a stream of bits and turns it into an object. If the stream contains the type of object you expect, all is well. But if <br /> you're deserializing untrusted input, and an attacker has inserted some other type of object, you're in trouble. Why? There are a few different attack <br /> scenarios, but one widely-documented one goes like this: Deserialization first instantiates an Object, then uses the <br /> readObject method to populate it. If the attacker has overridden readObject then he is entirely in control of what code <br /> executes during that process. It is only after readObject has completed that your newly-minted Object can be cast to the <br /> type you expected. A ClassCastException or ClassNotFoundException will be thrown, but at that point it's too late. <br /> Ask Yourself Whether <br />  <br />    an attacker could have tampered with the source provided to the deserialization function.  <br />    you are using an unsafe deserialization function. See the Recommended Secure Coding Practices for examples of safe libraries. <br />    <br />  <br /> You are at risk if you answered yes to any of those questions. <br />   <br /> Recommended Secure Coding Practices <br /> To prevent insecure deserialization, you should either use look-ahead deserialization (pre-Java 9) or a filter to make sure you're dealing with the <br /> correct type of object before you act on it. <br /> Several third-party libraries offer look-ahead deserialization, including: <br />  <br />    ikkisoft's SerialKiller  <br />    Apache Commons Class IO's ValidatingObjectInputStream  <br />    contrast-rO0's SafeObjectInputStream  <br />  <br /> Note that it is possible to set a deserialization filter at the level of the JVM, but relying on that requires that your environment be configured <br /> perfectly. Every time. Additionally, such a filter may have unwanted impacts on other applications in the environment. On the other hand, setting a <br /> filter as close as possible to the deserialization that uses it allows you to specify a very narrow, focused filter. <br /> You should also limit access to the serialized source. For example: <br />  <br />    if it is a file, restrict the access to it.  <br />    if it comes from the network, restrict who has access to the process, such as with a Firewall or by authenticating the sender first.  <br />  <br /> See <br />  <br />    OWASP - Deserialization of untrusted data  <br />    OWASP Top 10 2017 Category A8 - Insecure Deserialization <br />    <br />    MITRE, CWE-502 - Deserialization of Untrusted Data  <br />    Derived from FindSecBugs rule OBJECT_DESERIALIZATION   <br /> |SECURITY_HOTSPOT|CRITICAL|2
Using regular expressions is security-sensitive|Using regular expressions is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2017-16021  <br />    CVE-2018-13863  <br />  <br /> Evaluating regular expressions against input strings is potentially an extremely CPU-intensive task. Specially crafted regular expressions such as <br /> (a+)+s will take several seconds to evaluate the input string aaaaaaaaaaaaaaaaaaaaaaaaaaaaabs. The problem is that with <br /> every additional a character added to the input, the time required to evaluate the regex doubles. However, the equivalent regular <br /> expression, a+s (without grouping) is efficiently evaluated in milliseconds and scales linearly with the input size. <br /> Evaluating such regular expressions opens the door to Regular expression Denial of Service (ReDoS) attacks. In the <br /> context of a web application, attackers can force the web server to spend all of its resources evaluating regular expressions thereby making the <br /> service inaccessible to genuine users. <br /> This rule flags any execution of a hardcoded regular expression which has at least 3 characters and at least two instances of any of the following <br /> characters: *+{. <br /> Example: (a+)* <br /> Ask Yourself Whether <br />  <br />    the executed regular expression is sensitive and a user can provide a string which will be analyzed by this regular expression.  <br />    your regular expression engine performance decrease with specially crafted inputs and regular expressions.  <br />  <br /> You may be at risk if you answered yes to any of those questions. <br /> Recommended Secure Coding Practices <br /> Check whether your regular expression engine (the algorithm executing your regular expression) has any known vulnerabilities. Search for <br /> vulnerability reports mentioning the one engine you're are using. <br /> Use if possible a library which is not vulnerable to Redos Attacks such as Google Re2. <br /> Remember also that a ReDos attack is possible if a user-provided regular expression is executed. This rule won't detect this kind of injection. <br /> Sensitive Code Example <br />  <br /> import java.util.regex.Pattern; <br />  <br /> class BasePattern { <br />   String regex = "(a+)+b"; // a regular expression <br />   String input; // a user input <br />  <br />   void foo(CharSequence htmlString) { <br />     input.matches(regex);  // Sensitive <br />     Pattern.compile(regex);  // Sensitive <br />     Pattern.compile(regex, Pattern.CASE_INSENSITIVE);  // Sensitive <br />  <br />     String replacement = "test"; <br />     input.replaceAll(regex, replacement);  // Sensitive <br />     input.replaceFirst(regex, replacement);  // Sensitive <br />  <br />     if (!Pattern.matches(".*&lt;script&gt;(a+)+b", htmlString)) { // Sensitive <br />     } <br />   } <br /> } <br />  <br /> This also applies for bean validation, where regexp can be specified: <br />  <br /> import java.io.Serializable; <br /> import javax.validation.constraints.Pattern; <br /> import javax.validation.constraints.Email; <br /> import org.hibernate.validator.constraints.URL; <br />  <br /> class BeansRegex implements Serializable { <br />   @Pattern(regexp=".+@(a+)+b")  // Sensitive <br />   private String email; <br />  <br />   @Email(regexp=".+@(a+)+b")  // Sensitive <br />   private String email2; <br />  <br />   @URL(regexp="(a+)+b.com") // Sensitive <br />   private String url; <br />   // ... <br /> } <br />  <br /> Exceptions <br /> Calls to String.split(regex) and String.split(regex, limit) will not raise an exception despite their use of a regular <br /> expression. These methods are used most of the time to split on simple regular expressions which don't create any vulnerabilities. <br /> Some corner-case regular expressions will not raise an issue even though they might be vulnerable. For example: (a&#124aa)+, <br /> (a&#124a?)+. <br /> It is a good idea to test your regular expression if it has the same pattern on both side of a "&#124". <br /> See <br />  <br />    OWASP Top 10 2017 Category A1 - Injection  <br />    MITRE, CWE-624 - Executable Regular Expression Error <br />    <br />    OWASP Regular expression Denial of Service - ReDoS  <br /> |SECURITY_HOTSPOT|CRITICAL|2
Hashing data is security-sensitive|Hashing data is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2018-9233  <br />    CVE-2013-5097  <br />    CVE-2007-1051  <br />  <br /> Cryptographic hash functions are used to uniquely identify information without storing their original form. When not done properly, an attacker can <br /> steal the original information by guessing it (ex: with a rainbow table), or replace the <br /> original data with another one having the same hash. <br /> This rule flags code that initiates hashing. <br /> Ask Yourself Whether <br />  <br />    the hashed value is used in a security context.  <br />    the hashing algorithm you are using is known to have vulnerabilities.  <br />    salts are not automatically generated and applied by the hashing function. <br />    <br />    any generated salts are cryptographically weak or not credential-specific.  <br />  <br /> You are at risk if you answered yes to the first question and any of the following ones. <br /> Recommended Secure Coding Practices <br />  <br />    for security related purposes, use only hashing algorithms which are currently known to be strong. Avoid using algorithms like MD5 and SHA1 <br />   completely in security contexts.  <br />    do not define your own hashing- or salt algorithms as they will most probably have flaws.  <br />    do not use algorithms that compute too quickly, like SHA256, as it must remain beyond modern hardware capabilities to perform brute force and <br />   dictionary based attacks.  <br />    use a hashing algorithm that generate its own salts as part of the hashing. If you generate your own salts, make sure that a cryptographically <br />   strong salt algorithm is used, that generated salts are credential-specific, and finally, that the salt is applied correctly before the hashing. <br />    <br />    save both the salt and the hashed value in the relevant database record; during future validation operations, the salt and hash can then be <br />   retrieved from the database. The hash is recalculated with the stored salt and the value being validated, and the result compared to the stored <br />   hash.  <br />    the strength of hashing algorithms often decreases over time as hardware capabilities increase. Check regularly that the algorithms you are <br />   using are still considered secure. If needed, rehash your data using a stronger algorithm.  <br />  <br /> Sensitive Code Example <br />  <br /> // === MessageDigest === <br /> import java.security.MessageDigest; <br /> import java.security.Provider; <br />  <br /> class A { <br />     void foo(String algorithm, String providerStr, Provider provider) throws Exception { <br />         MessageDigest.getInstance(algorithm); // Sensitive <br />         MessageDigest.getInstance(algorithm, providerStr); // Sensitive <br />         MessageDigest.getInstance(algorithm, provider); // Sensitive <br />     } <br /> } <br />  <br /> Regarding SecretKeyFactory. Any call to SecretKeyFactory.getInstance("...") with an argument starting by <br /> "PBKDF2" will be highlighted. See OWASP guidelines, list of standard algorithms and algorithms on android. <br />  <br /> // === javax.crypto === <br /> import javax.crypto.spec.PBEKeySpec; <br /> import javax.crypto.SecretKeyFactory; <br />  <br /> class A { <br />     void foo(char[] password, byte[] salt, int iterationCount, int keyLength) throws Exception { <br />         // Sensitive. Review this, even if it is the way recommended by OWASP <br />         SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512"); <br />         PBEKeySpec spec = new PBEKeySpec(password, salt, iterationCount, keyLength); <br />         factory.generateSecret(spec).getEncoded(); <br />     } <br /> } <br />  <br /> Regarding Guava, only the hashing functions which are usually misused for sensitive data will raise an issue, i.e. md5 and <br /> sha*. <br />  <br /> // === Guava === <br /> import com.google.common.hash.Hashing; <br />  <br /> class A { <br />     void foo() { <br />         Hashing.md5(); // Sensitive <br />         Hashing.sha1(); // Sensitive <br />         Hashing.sha256(); // Sensitive <br />         Hashing.sha384(); // Sensitive <br />         Hashing.sha512(); // Sensitive <br />     } <br /> } <br />  <br />  <br /> // === org.apache.commons === <br /> import org.apache.commons.codec.digest.DigestUtils; <br />  <br /> class A { <br />     void foo(String strName, byte[] data, String str, java.io.InputStream stream) throws Exception { <br />         new DigestUtils(strName); // Sensitive <br />         new DigestUtils(); // Sensitive <br />  <br />         DigestUtils.getMd2Digest(); // Sensitive <br />         DigestUtils.getMd5Digest(); // Sensitive <br />         DigestUtils.getShaDigest(); // Sensitive <br />         DigestUtils.getSha1Digest(); // Sensitive <br />         DigestUtils.getSha256Digest(); // Sensitive <br />         DigestUtils.getSha384Digest(); // Sensitive <br />         DigestUtils.getSha512Digest(); // Sensitive <br />  <br />  <br />         DigestUtils.md2(data); // Sensitive <br />         DigestUtils.md2(stream); // Sensitive <br />         DigestUtils.md2(str); // Sensitive <br />         DigestUtils.md2Hex(data); // Sensitive <br />         DigestUtils.md2Hex(stream); // Sensitive <br />         DigestUtils.md2Hex(str); // Sensitive <br />  <br />         DigestUtils.md5(data); // Sensitive <br />         DigestUtils.md5(stream); // Sensitive <br />         DigestUtils.md5(str); // Sensitive <br />         DigestUtils.md5Hex(data); // Sensitive <br />         DigestUtils.md5Hex(stream); // Sensitive <br />         DigestUtils.md5Hex(str); // Sensitive <br />  <br />         DigestUtils.sha(data); // Sensitive <br />         DigestUtils.sha(stream); // Sensitive <br />         DigestUtils.sha(str); // Sensitive <br />         DigestUtils.shaHex(data); // Sensitive <br />         DigestUtils.shaHex(stream); // Sensitive <br />         DigestUtils.shaHex(str); // Sensitive <br />  <br />         DigestUtils.sha1(data); // Sensitive <br />         DigestUtils.sha1(stream); // Sensitive <br />         DigestUtils.sha1(str); // Sensitive <br />         DigestUtils.sha1Hex(data); // Sensitive <br />         DigestUtils.sha1Hex(stream); // Sensitive <br />         DigestUtils.sha1Hex(str); // Sensitive <br />  <br />         DigestUtils.sha256(data); // Sensitive <br />         DigestUtils.sha256(stream); // Sensitive <br />         DigestUtils.sha256(str); // Sensitive <br />         DigestUtils.sha256Hex(data); // Sensitive <br />         DigestUtils.sha256Hex(stream); // Sensitive <br />         DigestUtils.sha256Hex(str); // Sensitive <br />  <br />         DigestUtils.sha384(data); // Sensitive <br />         DigestUtils.sha384(stream); // Sensitive <br />         DigestUtils.sha384(str); // Sensitive <br />         DigestUtils.sha384Hex(data); // Sensitive <br />         DigestUtils.sha384Hex(stream); // Sensitive <br />         DigestUtils.sha384Hex(str); // Sensitive <br />  <br />         DigestUtils.sha512(data); // Sensitive <br />         DigestUtils.sha512(stream); // Sensitive <br />         DigestUtils.sha512(str); // Sensitive <br />         DigestUtils.sha512Hex(data); // Sensitive <br />         DigestUtils.sha512Hex(stream); // Sensitive <br />         DigestUtils.sha512Hex(str); // Sensitive <br />     } <br /> } <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    OWASP Top 10 2017 Category A6 - Security <br />   Misconfiguration  <br />    MITRE, CWE-916 - Use of Password Hash With Insufficient Computational Effort <br />    <br />    MITRE, CWE-759 - Use of a One-Way Hash without a Salt  <br />    MITRE, CWE-760 - Use of a One-Way Hash with a Predictable Salt  <br />    SANS Top 25 - Porous Defenses  <br /> |SECURITY_HOTSPOT|CRITICAL|1
Using Sockets is security-sensitive|Using sockets is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2011-178  <br />    CVE-2017-5645  <br />    CVE-2018-6597  <br />  <br /> Sockets are vulnerable in multiple ways: <br />  <br />    They enable a software to interact with the outside world. As this world is full of attackers it is necessary to check that they cannot receive <br />   sensitive information or inject dangerous input.  <br />    The number of sockets is limited and can be exhausted. Which makes the application unresponsive to users who need additional sockets.  <br />  <br /> This rules flags code that creates sockets. It matches only the direct use of sockets, not use through frameworks or high-level APIs such as the <br /> use of http connections. <br /> Ask Yourself Whether <br />  <br />    sockets are created without any limit every time a user performs an action.  <br />    input received from sockets is used without being sanitized.  <br />    sensitive data is sent via sockets without being encrypted.  <br />  <br /> You are at risk if you answered yes to any of these questions. <br /> Recommended Secure Coding Practices <br />  <br />    In many cases there is no need to open a socket yourself. Use instead libraries and existing protocols.  <br />    Encrypt all data sent if it is sensitive. Usually it is better to encrypt it even if the data is not sensitive as it might change later.  <br />    Sanitize any input read from the socket.  <br />    Limit the number of sockets a given user can create. Close the sockets as soon as possible.  <br />  <br /> Sensitive Code Example <br />  <br /> // === java.net === <br /> import java.net.Socket; <br /> import java.net.InetAddress; <br /> import java.net.Proxy; <br /> import java.net.ServerSocket; <br /> import javax.net.SocketFactory; <br />  <br /> class A { <br />     void foo(SocketFactory factory, String address, int port, InetAddress localAddr, int localPort, boolean stream, <br />             String host, Proxy proxy, int backlog, InetAddress bindAddr) <br />             throws Exception { <br />         new Socket(); // Questionable. <br />         new Socket(address, port); // Questionable. <br />         new Socket(address, port, localAddr, localPort); // Questionable. <br />         new Socket(host, port, stream); // Questionable. <br />         new Socket(proxy); // Questionable. <br />         new Socket(host, port); // Questionable. <br />         new Socket(host, port, stream); // Questionable. <br />         new Socket(host, port, localAddr, localPort); // Questionable. <br />  <br />         new ServerSocket(); // Questionable. <br />         new ServerSocket(port); // Questionable. <br />         new ServerSocket(port, backlog); // Questionable. <br />         new ServerSocket(port, backlog, bindAddr); // Questionable. <br />  <br />         factory.createSocket(); // Questionable <br />     } <br /> } <br />  <br /> abstract class mySocketFactory extends SocketFactory { // Questionable. Review how the sockets are created. <br />     // ... <br /> } <br />  <br />  <br /> // === java.nio.channels === <br /> import java.net.SocketAddress; <br /> import java.nio.channels.AsynchronousChannelGroup; <br /> import java.nio.channels.AsynchronousServerSocketChannel; <br /> import java.nio.channels.AsynchronousSocketChannel; <br /> import java.nio.channels.SocketChannel; <br /> import java.nio.channels.ServerSocketChannel; <br />  <br /> class A { <br />     void foo(AsynchronousChannelGroup group, SocketAddress remote) throws Exception { <br />         AsynchronousServerSocketChannel.open(); // Questionable. <br />         AsynchronousServerSocketChannel.open(group); // Questionable. <br />         AsynchronousSocketChannel.open(); // Questionable. <br />         AsynchronousSocketChannel.open(group); // Questionable. <br />         SocketChannel.open(); // Questionable. <br />         SocketChannel.open(remote); // Questionable. <br />         ServerSocketChannel.open(); // Questionable. <br />     } <br /> } <br />  <br />  <br /> // === Netty === <br /> import io.netty.channel.ChannelInitializer; <br /> import io.netty.channel.socket.ServerSocketChannel; <br /> import io.netty.channel.socket.SocketChannel; <br />  <br /> class CustomChannelInitializer extends ChannelInitializer&lt;ServerSocketChannel&gt; { // Questionable. Review how the SocketChannel is used. <br />     @Override <br />     protected void initChannel(ServerSocketChannel ch) throws Exception { <br />     } <br /> } <br />  <br /> class A { <br />     void foo() { <br />         new ChannelInitializer&lt;SocketChannel&gt;() {  // Questionable <br />             @Override <br />             public void initChannel(SocketChannel ch) throws Exception { <br />                 // ... <br />             } <br />         }; <br />     } <br /> } <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    MITRE, CWE-20 - Improper Input Validation  <br />    MITRE, CWE-400 - Uncontrolled Resource Consumption ('Resource Exhaustion')  <br />    MITRE, CWE-200 - Information Exposure  <br />    SANS Top 25 - Risky Resource Management  <br />    SANS Top 25 - Porous Defenses  <br /> |SECURITY_HOTSPOT|CRITICAL|3
Using command line arguments is security-sensitive|Using command line arguments is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2018-7281  <br />    CVE-2018-12326  <br />    CVE-2011-3198  <br />  <br /> Command line arguments can be dangerous just like any other user input. They should never be used without being first validated and sanitized. <br /> Remember also that any user can retrieve the list of processes running on a system, which makes the arguments provided to them visible. Thus <br /> passing sensitive information via command line arguments should be considered as insecure. <br /> This rule raises an issue when on every program entry points (main methods) when command line arguments are used. The goal is to guide <br /> security code reviews. <br /> Ask Yourself Whether <br />  <br />    any of the command line arguments are used without being sanitized first.  <br />    your application accepts sensitive information via command line arguments.  <br />  <br /> If you answered yes to any of these questions you are at risk. <br /> Recommended Secure Coding Practices <br /> Sanitize all command line arguments before using them. <br /> Any user or application can list running processes and see the command line arguments they were started with. There are safer ways of providing <br /> sensitive information to an application than exposing them in the command line. It is common to write them on the process' standard input, or give the <br /> path to a file containing the information. <br /> Sensitive Code Example <br /> This rule raises an issue as soon as there is a reference to argv, be it for direct use or via a CLI library like JCommander, GetOpt or Apache <br /> CLI. <br />  <br /> public class Main { <br /> &nbsp;&nbsp;&nbsp; public static void main (String[] argv) { <br /> &nbsp; &nbsp; &nbsp; &nbsp; String option = argv[0]; &nbsp;// Questionable: check how the argument is used <br /> &nbsp;&nbsp;&nbsp; } <br /> } <br />  <br />  <br /> // === JCommander === <br /> import&nbsp;com.beust.jcommander.*; <br />  <br /> public class Main { <br /> &nbsp;&nbsp;&nbsp; public static void main (String[] argv) { <br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Main main = new Main(); <br /> &nbsp; &nbsp; &nbsp; &nbsp; JCommander.newBuilder() <br /> &nbsp; &nbsp; &nbsp; &nbsp; .addObject(main) <br /> &nbsp; &nbsp; &nbsp; &nbsp; .build() <br /> &nbsp; &nbsp; &nbsp; &nbsp; .parse(argv); // Questionable <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;main.run(); <br /> &nbsp;&nbsp; &nbsp;} <br /> } <br />  <br />  <br /> // === GNU Getopt === <br /> import gnu.getopt.Getopt; <br />  <br /> public class Main { <br /> &nbsp;&nbsp;&nbsp; public static void main (String[] argv) { <br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Getopt g = new Getopt("myprog", argv, "ab"); // Questionable <br /> &nbsp;&nbsp;&nbsp; } <br /> } <br />  <br />  <br /> // === Apache CLI === <br /> import org.apache.commons.cli.*; <br />  <br /> public class Main { <br /> &nbsp;&nbsp;&nbsp; public static void main (String[] argv) { <br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Options options = new Options(); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; CommandLineParser parser = new DefaultParser(); <br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;try { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  CommandLine line = parser.parse(options, argv); // Questionable <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; } <br /> &nbsp;&nbsp;&nbsp; } <br /> } <br />  <br /> In the case of Args4J, an issue is created on the public void run method of any class using org.kohsuke.args4j.Option or <br /> org.kohsuke.args4j.Argument. <br /> Such a class is called directly by org.kohsuke.args4j.Starter outside of any public static void main method. If the class <br /> has no run method, no issue will be raised as there must be a public static void main and its argument is already <br /> highlighted. <br />  <br /> // === argv4J === <br /> import org.kohsuke.args4j.Option; <br /> import org.kohsuke.args4j.Argument; <br />  <br /> public class Main { <br />     @Option(name="-myopt",usage="An option") <br />     public String myopt; <br />  <br />     @Argument(usage = "An argument", metaVar = "&lt;myArg&gt;") <br />     String myarg; <br />  <br />     String file; <br />  <br />     @Option(name="-file") <br />     public void setFile(String file) { <br />         this.file = file; <br />     } <br />  <br />     String arg2; <br />  <br />     @Argument(index=1) <br />     public void setArg2(String arg2) { <br />         this.arg2 = arg2; <br />     } <br />  <br /> &nbsp;&nbsp; &nbsp;public void run() { // Questionable: This function <br />         myarg; // check how this argument is used <br /> &nbsp;&nbsp; &nbsp;} <br /> } <br />  <br /> Exceptions <br /> The support of Argv4J without the use of org.kohsuke.argv4j.Option is out of scope as there is no way to know which Bean will be used <br /> as the mainclass. <br /> No issue will be raised on public static void main(String[] argv) if argv is not referenced in the method. <br /> See <br />  <br />    OWASP Top 10 2017 Category A1 - Injection  <br />    MITRE, CWE-88 - Argument Injection or Modification  <br />    MITRE, CWE-214 - Information Exposure Through Process Environment  <br />    SANS Top 25 - Insecure Interaction Between Components  <br /> |SECURITY_HOTSPOT|CRITICAL|5
Reading the Standard Input is security-sensitive|Reading Standard Input is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2005-2337  <br />    CVE-2017-11449  <br />  <br /> It is common for attackers to craft inputs enabling them to exploit software vulnerabilities. Thus any data read from the standard input (stdin) <br /> can be dangerous and should be validated. <br /> This rule flags code that reads from the standard input. <br /> Ask Yourself Whether <br />  <br />    data read from the standard input is not sanitized before being used.  <br />  <br /> You are at risk if you answered yes to this question. <br /> Recommended Secure Coding Practices <br /> Sanitize all data read from the standard input before using it. <br /> Sensitive Code Example <br />  <br /> class A { <br />     void foo(String fmt, Object args) throws Exception { <br />         // Questionable. Check how the standard input is used. <br />         System.in.read(); <br />  <br />         // Questionable. Check how safe this new InputStream is. <br />         System.setIn(new java.io.FileInputStream("test.txt")); <br />  <br />         java.io.Console console = System.console(); <br />         // Questionable. All the following calls should be reviewed as they use the standard input. <br />         console.reader(); <br />         console.readLine(); <br />         console.readLine(fmt, args); <br />         console.readPassword(); <br />         console.readPassword(fmt, args); <br />     } <br /> } <br />  <br /> Exceptions <br /> All references to System.in will create issues except direct calls to System.in.close(). <br /> Command line parsing libraries such as JCommander often read standard input when asked for passwords. However this rule doesn't raise any issue in <br /> this case as another hotspot rule covers command line arguments. <br /> See: <br />  <br />    MITRE, CWE-20 - Improper Input Validation  <br /> |SECURITY_HOTSPOT|CRITICAL|3
Expanding archive files is security-sensitive|Expanding archive files is security-sensitive. For example, expanding archive files has led in the past to the following vulnerabilities: <br />  <br />    CVE-2018-1263  <br />    CVE-2018-16131  <br />  <br /> Applications that expand archive files (zip, tar, jar, war, 7z, ...) should verify the path where the archive's files are expanded and not trust <br /> blindly the content of the archive. Archive's files should not be expanded outside of the root directory where the archive is supposed to be expanded. <br /> Also, applications should control the size of the expanded data to not be a victim of Zip Bomb attack. Failure to do so could allow an attacker to use <br /> a specially crafted archive that holds directory traversal paths (e.g. ../../attacker.sh) or the attacker could overload the file system, processors <br /> or memory of the operating system where the archive is expanded making the target OS completely unusable. <br /> This rule raises an issue when code handle archives. The goal is to guide security code reviews. <br /> Ask Yourself Whether <br />  <br />    there is no validation of the name of the archive entry  <br />    there is no validation of the effective path where the archive entry is going to be expanded  <br />    there is no validation of the size of the expanded archive entry  <br />    there is no validation of the ratio between the compressed and uncompressed archive entry  <br />  <br /> You are at risk if you answered yes to any of those questions. <br />   <br /> Recommended Secure Coding Practices <br />  <br />    Validate the full path of the extracted file against the full path of the directory where files are uncompressed. <br />      <br />        the canonical path of the uncompressed file must start with the canonical path of the directory where files are extracted.  <br />        the name of the archive entry must not contain "..", i.e. reference to a parent directory.  <br />       <br />  <br />  <br /> String canonicalDirPath = outputDir.getCanonicalPath(); <br /> String canonicalDestPath = targetFile.getCanonicalPath(); <br />  <br /> if (!canonicalDestPath.startsWith(canonicalDirPath + File.separator)) { // Sanitizer <br />   throw new ArchiverException("Entry is trying to leave the target dir: " + zipEntry.getName()); <br /> } <br />  <br />  <br />    Stop extracting the archive if any of its entries has been tainted with a directory traversal path.  <br />    Define and control the ratio between compressed and uncompress bytes.  <br />    Define and control the maximum allowed uncompressed file size.  <br />    Count the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold. <br />    <br />  <br /> Sensitive Code Example <br />  <br /> java.util.zip.ZipFile zipFile = new ZipFile(zipFileName); <br />  <br /> Enumeration&lt;? extends ZipEntry&gt; entries = zipFile.entries(); <br /> while (entries.hasMoreElements()) { <br />   ZipEntry e = entries.nextElement(); // Questionable <br />   File f = new File(outputDir, e.getName()); <br />   InputStream input = zipFile.getInputStream(e); <br />   extractFile(new ZipInputStream(input), outputDir, e.getName()); <br /> } <br />  <br /> Exceptions <br /> This rule doesn't raise an issue when a ZipEntry or a ArchiveEntry: <br />  <br />    is declared as a class field  <br />    is a parameter of an abstract method of an interface or abstract class  <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A1 - Injection  <br />    MITRE, CWE-409 - Improper Handling of Highly Compressed Data (Data Amplification) <br />    <br />    CERT, IDS04-J. - Safely <br />   extract files from ZipInputStream  <br />    Snyk Research Team: Zip Slip Vulnerability  <br /> |SECURITY_HOTSPOT|CRITICAL|7
Using environment variables is security-sensitive|Using environment variables is security-sensitive. For example, their use has led in the past to the following vulnerabilities: <br />  <br />    CVE-2014-6278  <br />    CVE-2019-3464  <br />    CVE-2018-1000402  <br />    CVE-2016-10530  <br />  <br /> Environment variables are sensitive to injection attacks, just like any other input. <br /> Note also that environment variables can be exposed in multiple ways, storing sensitive information in them should be done carefully: <br />  <br />    on Unix systems environment variables of one process can be read by another process running with the same UID.  <br />    environment variables might be forwarded to child <br />   processes.  <br />    application running in debug mode often exposes their environment variable.  <br />  <br /> This rule raises an issue when environment variables are read. <br /> Ask Yourself Whether <br />  <br />    Environment variables are used without being sanitized.  <br />    You store sensitive information in environment variables and other processes might be able to access them.  <br />  <br /> You are at risk if you answered yes to any of those questions. <br /> Recommended Secure Coding Practices <br /> Sanitize every environment variable before using its value. <br /> If you store sensitive information in an environment variable, make sure that no other process can access them, i.e. the process runs with a <br /> separate user account and child processes don't have access to their parent's environment. <br /> Don't run your application in debug mode if it has access to sensitive information, including environment variables. <br /> Sensitive Code Example <br />  <br /> public class Main { <br />     public static void main (String[] args) { <br />         System.getenv();  // Sensitive <br />         System.getenv("myvar");  // Sensitive <br />  <br />         ProcessBuilder processBuilder = new ProcessBuilder(); <br />         Map&lt;String, String&gt; environment = processBuilder.environment();  // Sensitive <br />         environment.put("VAR", "value"); <br />  <br />         Runtime.getRuntime().exec("ping", new String[]{"env=val"});   // Sensitive <br />     } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-526 - Information Exposure Through Environmental Variables  <br />    MITRE, CWE-74 - Improper Neutralization of Special Elements in Output Used by a <br />   Downstream Component ('Injection')  <br /> |SECURITY_HOTSPOT|CRITICAL|5
Using hardcoded IP addresses is security-sensitive|Hardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2006-5901  <br />    CVE-2005-3725  <br />  <br /> Today's services have an ever-changing architecture due to their scaling and redundancy needs. It is a mistake to think that a service will always <br /> have the same IP address. When it does change, the hardcoded IP will have to be modified too. This will have an impact on the product development, <br /> delivery and deployment: <br />  <br />    The developers will have to do a rapid fix every time this happens, instead of having an operation team change a configuration file.  <br />    It forces the same address to be used in every environment (dev, sys, qa, prod).  <br />  <br /> Last but not least it has an effect on application security. Attackers might be able to decompile the code and thereby discover a potentially <br /> sensitive address. They can perform a Denial of Service attack on the service at this address or spoof the IP address. Such an attack is always <br /> possible, but in the case of a hardcoded IP address the fix will be much slower, which will increase an attack's impact. <br /> Recommended Secure Coding Practices <br />  <br />    make the IP address configurable.  <br />  <br /> Noncompliant Code Example <br />  <br /> String ip = "192.168.12.42"; // Noncompliant <br /> Socket socket = new Socket(ip, 6667); <br />  <br /> Exceptions <br /> No issue is reported for the following cases because they are not considered sensitive: <br />  <br />    Loopback addresses 127.0.0.0/8 in CIDR notation (from 127.0.0.0 to 127.255.255.255)  <br />    Broadcast address 255.255.255.255  <br />    Non routable address 0.0.0.0  <br />    Strings of the form 2.5.&lt;number&gt;.&lt;number&gt; as they often match <br />   Object Identifiers (OID).  <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    CERT, MSC03-J. - Never hard code sensitive information  <br /> |SECURITY_HOTSPOT|MINOR|1
Untrusted XML should be parsed without resolving external data|Allowing external DTD entities in untrusted documents to be processed could lay your systems bare to attackers. Imagine if these entities were <br /> parsed: <br />  <br /> &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; <br /> &lt;!ENTITY xxe SYSTEM "http://www.attacker.com/text.txt" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; <br />  <br /> If you must parse untrusted XML, the best way to protect yourself is to only accept an embedded DTD or, even better, completely ignore any DTD <br /> declared in the document. <br /> This rule raises an issue when any of the following are used without first disabling external entity processing: <br /> javax.xml.validation.Validator, JAXP's DocumentBuilderFactory, SAXParserFactory, Xerces 1 and Xerces 2 StAX's <br /> XMLInputFactory and XMLReaderFactory. <br /> To disable external entity processing for XMLInputFactory, configure one of the properties <br /> XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES or XMLInputFactory.SUPPORT_DTD to false. <br /> To disable external entity processing for SAXParserFactory, XMLReader or DocumentBuilderFactory configure <br /> one of the features XMLConstants.FEATURE_SECURE_PROCESSING or "http://apache.org/xml/features/disallow-doctype-decl" to <br /> true. <br /> To disable external entity processing for Validator, configure both properties XMLConstants.ACCESS_EXTERNAL_DTD, <br /> XMLConstants.ACCESS_EXTERNAL_SCHEMA to the empty string "". <br /> Noncompliant Code Example <br />  <br /> /* Load XML stream and display content */ <br /> String maliciousSample = "xxe.xml"; <br /> XMLInputFactory factory = XMLInputFactory.newInstance(); <br />  <br /> try (FileInputStream fis = new FileInputStream(malicousSample)) { <br />   // Load XML stream <br />   XMLStreamReader xmlStreamReader = factory.createXMLStreamReader(fis);  // Noncompliant; reader is vulnerable <br />  <br /> Compliant Solution <br />  <br /> /* Load XML stream and display content */ <br /> String maliciousSample = "xxe.xml"; <br /> XMLInputFactory factory = XMLInputFactory.newInstance(); <br />  <br /> // disable resolving of external DTD entities <br /> factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE); <br />  <br /> // or disallow DTDs entirely <br /> factory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE); <br />  <br /> try (FileInputStream fis = new FileInputStream(malicousSample)) { <br />     // Load XML stream <br />     XMLStreamReader xmlStreamReader = factory.createXMLStreamReader(fis); <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A4 - XML External Entities <br />   (XXE)  <br />    OWASP XXE Prevention Cheat Sheet  <br />    MITRE, CWE-611 - Information Exposure Through XML External Entity Reference  <br />    MITRE, CWE-827 - Improper Control of Document Type Definition  <br />    Derived from FindSecBugs rule XXE_XMLSTREAMREADER  <br />    Derived from FindSecBugs rule XXE_SAXPARSER  <br />    Derived from FindSecBugs rule XXE_XMLREADER  <br />    Derived from FindSecBugs rule XXE_DOCUMENT  <br /> |VULNERABILITY|BLOCKER|3
Class variable fields should not have public accessibility|Public class variable fields do not respect the encapsulation principle and has three main disadvantages: <br />  <br />    Additional behavior such as validation cannot be added.  <br />    The internal representation is exposed, and cannot be changed afterwards.  <br />    Member values are subject to change from anywhere in the code and may not meet the programmer's assumptions.  <br />  <br /> By using private attributes and accessor methods (set and get), unauthorized modifications are prevented. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />  <br />   public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked <br />  <br />   public String firstName;                       // Noncompliant <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />  <br />   public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked <br />  <br />   private String firstName;                      // Compliant <br />  <br />   public String getFirstName() { <br />     return firstName; <br />   } <br />  <br />   public void setFirstName(String firstName) { <br />     this.firstName = firstName; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> Because they are not modifiable, this rule ignores public final fields. <br /> See <br />  <br />    MITRE, CWE-493 - Critical Public Variable Without Final Modifier  <br /> |VULNERABILITY|MINOR|161
Throwable.printStackTrace(...) should not be called|Throwable.printStackTrace(...) prints a Throwable and its stack trace to some stream. By default that stream <br /> System.Err, which could inadvertently expose sensitive information. <br /> Loggers should be used instead to print Throwables, as they have many advantages: <br />  <br />    Users are able to easily retrieve the logs.  <br />    The format of log messages is uniform and allow users to browse the logs easily.  <br />  <br /> This rule raises an issue when printStackTrace is used without arguments, i.e. when the stack trace is printed to the default <br /> stream. <br /> Noncompliant Code Example <br />  <br /> try { <br />   /* ... */ <br /> } catch(Exception e) { <br />   e.printStackTrace();        // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> try { <br />   /* ... */ <br /> } catch(Exception e) { <br />   LOGGER.log("context", e); <br /> } <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    MITRE, CWE-489 - Leftover Debug Code  <br /> |VULNERABILITY|MINOR|12
"public static" fields should be constant|There is no good reason to declare a field "public" and "static" without also declaring it "final". Most of the time this is a kludge to share a <br /> state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to <br /> null.  <br /> Noncompliant Code Example <br />  <br /> public class Greeter { <br />   public static Foo foo = new Foo(); <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Greeter { <br />   public static final Foo FOO = new Foo(); <br />   ... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-500 - Public Static Field Not Marked Final  <br />    CERT OBJ10-J. - Do not use public static nonfinal fields  <br /> |VULNERABILITY|MINOR|47
Mutable fields should not be "public static"|There is no good reason to have a mutable object as the public (by default), static member of an interface. <br /> Such variables should be moved into classes and their visibility lowered.  <br /> Similarly, mutable static members of classes and enumerations which are accessed directly, rather than through getters and setters, <br /> should be protected to the degree possible. That can be done by reducing visibility or making the field final if appropriate.  <br /> Note that making a mutable field, such as an array, final will keep the variable from being reassigned, but doing so has no effect on <br /> the mutability of the internal state of the array (i.e. it doesn't accomplish the goal). <br /> This rule raises issues for public static array, Collection, Date, and awt.Point members. <br /> Noncompliant Code Example <br />  <br /> public interface MyInterface { <br />   public static String [] strings; // Noncompliant <br /> } <br />  <br /> public class A { <br />   public static String [] strings1 = {"first","second"};  // Noncompliant <br />   public static String [] strings2 = {"first","second"};  // Noncompliant <br />   public static List&lt;String&gt; strings3 = new ArrayList&lt;&gt;();  // Noncompliant <br />   // ... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-582 - Array Declared Public, Final, and Static  <br />    MITRE, CWE-607 - Public Static Final Field References Mutable Object  <br />    CERT, OBJ01-J. - Limit accessibility of fields  <br />    CERT, OBJ13-J. - Ensure that references to mutable objects are not exposed <br />    <br /> |VULNERABILITY|MINOR|7
Return values should not be ignored when they contain the operation status code|When the return value of a function call contain the operation status code, this value should be tested to make sure the operation completed <br /> successfully. <br /> This rule raises an issue when the return values of the following are ignored: <br />  <br />    java.io.File operations that return a status code (except mkdirs)  <br />    Iterator.hasNext()  <br />    Enumeration.hasMoreElements()  <br />    Lock.tryLock()  <br />    non-void Condition.await* methods  <br />    CountDownLatch.await(long, TimeUnit)  <br />    Semaphore.tryAcquire  <br />    BlockingQueue: offer, remove  <br />  <br /> Noncompliant Code Example <br />  <br /> public void doSomething(File file, Lock lock) { <br />   file.delete();  // Noncompliant <br />   // ... <br />   lock.tryLock(); // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(File file, Lock lock) { <br />   if (!lock.tryLock()) { <br />     // lock failed; take appropriate action <br />   } <br />   if (!file.delete()) { <br />     // file delete failed; take appropriate action <br />   } <br /> } <br />  <br /> See <br />  <br />    MISRA C:2004, 16.10 - If a function returns error information, then that error information shall be tested  <br />    MISRA C++:2008, 0-1-7 - The value returned by a function having a non-void return type that is not an overloaded operator shall always be used. <br />    <br />    MISRA C:2012, Dir. 4.7 - If a function returns error information, then that error information shall be tested  <br />    MISRA C:2012, 17.7 - The value returned by a function having non-void return type shall be used  <br />    CERT, ERR33-C. - Detect and handle standard library errors  <br />    CERT, POS54-C. - Detect and handle POSIX library errors  <br />    CERT, EXP00-J. - Do not ignore values returned by methods  <br />    CERT, EXP12-C. - Do not ignore values returned by functions  <br />    CERT, FIO02-J. - Detect and handle file-related errors  <br />    MITRE, CWE-754 - Improper Check for Unusual Exceptional Conditions  <br /> |VULNERABILITY|MINOR|28
